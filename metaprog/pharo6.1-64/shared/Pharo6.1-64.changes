----QUIT----2018-10-26T11:28:58.877899+02:00 Pharo6.1-64.image priorSource: 7863927!!Obj methodsFor: 'method lookup' stamp: 'pm 11/2/2018 08:56' prior: 36338954!lookup: arg1! !!Obj methodsFor: 'method management' stamp: 'pm 11/2/2018 08:56' prior: 36338678!bodyOfMethod: arg1	^self objMethodDict associationAt: arg1 ifAbsent: [ nil ]! !!Obj methodsFor: 'method management' stamp: 'pm 11/2/2018 08:56' prior: 33554696!bodyOfMethod: arg1	^self objMethodDict associationAt: arg1 ifAbsent: [ nil ].! !!Obj methodsFor: 'message passing' stamp: 'pm 11/2/2018 15:41' prior: 36339607!send: arg1 withArguments: arg2	^self basicSend: arg1 withArguments: arg2 from: (self objClass).! !!Obj methodsFor: 'message passing' stamp: 'pm 11/2/2018 15:41' prior: 33555021!send: arg1 withArguments: arg2	"or is it?"	^self basicSend: arg1 withArguments: arg2 from: (self objClass).! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/2/2018 15:46' prior: 33554597!lookup: arg1	! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/2/2018 15:57' prior: 33555392!lookup: arg1	"question, do we have to search in metaclass aswell?	answer might be later in the tutorial"	| Method Super|	Method:=self bodyOfMethod:arg1.	Method isNil	ifFalse:[		^Method."we found a corresponding selector"		].	"else"	"we do the lookup in the superclass."	Super:=self objSuperclass.	Super isNil	ifTrue:[		^Super lookup:arg1.		]	ifFalse:[		^nil		].		! !!Obj methodsFor: 'message passing' stamp: 'pm 11/2/2018 16:07' prior: 36339607!send: arg1 withArguments: arg2	^self! !!Obj methodsFor: 'method management' stamp: 'pm 11/2/2018 16:08' prior: 36338678!bodyOfMethod: arg1	^self objMethodDict associationAt: arg1 ifAbsent: [ nil ].! !!Obj methodsFor: 'message passing' stamp: 'pm 11/2/2018 16:08' prior: 33555958!send: arg1 withArguments: arg2	"or is it?"	^self basicSend: arg1 withArguments: arg2 from: (self objClass).! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/2/2018 16:08' prior: 36338954!lookup: arg1	"question, do we have to search in metaclass aswell?	answer might be later in the tutorial"	| Method Super|	Method:=self bodyOfMethod:arg1.	Method isNil	ifFalse:[		^Method."we found a corresponding selector"		].	"else"	"we do the lookup in the superclass."	Super:=self objSuperclass.	Super isNil	ifTrue:[		^Super lookup:arg1.		]	ifFalse:[		^nil		].		! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/2/2018 16:08' prior: 33556243!send: arg1 withArguments: arg2	"or is it?"	"^self basicSend: arg1 withArguments: arg2 from: (self objClass)."! !----SNAPSHOT----2018-11-02T16:08:35.949161+01:00 Pharo6.1-64.image priorSource: 2785527!----QUIT----2018-11-02T16:09:05.709094+01:00 Pharo6.1-64.image priorSource: 2583!!Obj methodsFor: 'method lookup' stamp: 'pm 11/2/2018 16:39' prior: 33556901!send: arg1 withArguments: arg2	"or is it?"	self halt.	"^self basicSend: arg1 withArguments: arg2 from: (self objClass)."! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/2/2018 16:40' prior: 33557267!send: arg1 withArguments: arg2	"or is it?"		"^self basicSend: arg1 withArguments: arg2 from: (self objClass)."! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/2/2018 16:40' prior: 33557472!send: arg1 withArguments: arg2	"or is it?"		^self basicSend: arg1 withArguments: arg2 from: (self objClass).! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/2/2018 16:41' prior: 33556434!lookup: arg1	"question, do we have to search in metaclass aswell?	answer might be later in the tutorial"	| Method Super|	self halt.	Method:=self bodyOfMethod:arg1.	Method isNil	ifFalse:[		^Method."we found a corresponding selector"		].	"else"	"we do the lookup in the superclass."	Super:=self objSuperclass.	Super isNil	ifTrue:[		^Super lookup:arg1.		]	ifFalse:[		^nil		].		! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/2/2018 16:44' prior: 33557860!lookup: arg1	"question, do we have to search in metaclass aswell?	answer might be later in the tutorial"	| Method Super|	self halt.	Method:=self bodyOfMethod:arg1.	Method isNil	ifFalse:[		^Method."we found a corresponding selector"		].	"else"	"we do the lookup in the superclass."	Super:=self objSuperclass.	Super ~= self 	ifTrue:[		^Super lookup:arg1.		]	ifFalse:[		^nil		].		! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/2/2018 16:45' prior: 33558339!lookup: arg1	"question, do we have to search in metaclass aswell?	answer might be later in the tutorial"	| Method Super|	Method:=self bodyOfMethod:arg1.	Method isNil	ifFalse:[		^Method."we found a corresponding selector"		].	"else"	"we do the lookup in the superclass."	Super:=self objSuperclass.	Super ~= self 	ifTrue:[		^Super lookup:arg1.		]	ifFalse:[		^nil		].		! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/2/2018 16:49' prior: 33558821!lookup: arg1	"question, do we have to search in metaclass aswell?	answer might be later in the tutorial"	| Method Super|	Method:=self bodyOfMethod:arg1.	Method isNil	ifFalse:[		^Method."we found a corresponding selector"		].	"else"	"we do the lookup in the superclass."	Super:=self objSuperclass.	((Super isNil) or:[Super == self])	ifTrue:[		^nil		]	ifFalse:[		^Super lookup:arg1.		].		! !----SNAPSHOT----2018-11-02T16:49:51.458476+01:00 Pharo6.1-64.image priorSource: 2673!!Obj methodsFor: 'method lookup' stamp: 'pm 11/2/2018 16:51' prior: 33559292!lookup: arg1	"question, do we have to search in metaclass aswell?	answer might be later in the tutorial"	| Method Super|	Method:=self bodyOfMethod:arg1.	Method isNil	ifFalse:[		^Method."we found a corresponding selector"		].	"else"	"we do the lookup in the superclass."	((self objSuperclassId) isNil)	ifTrue:[		^nil.		].	Super:=self objSuperclass.	Super == self	ifTrue:[		^nil		]	ifFalse:[		^Super lookup:arg1.		].		! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/2/2018 16:59' prior: 33559870!lookup: arg1	"question, do we have to search in metaclass aswell?	answer might be later in the tutorial"	| Method Super|	Method:=self bodyOfMethod:arg1.	Method isNil	ifFalse:[		^Method."we found a corresponding selector"		].	"else"	"we do the lookup in the superclass."	(((self objSuperclassId) isNil) or:[	Super == self])"if we don't have a super class, or we're reflexive, we fail."	ifTrue:[		^nil.		].	Super:=self objSuperclass.	^Super lookup:arg1.		! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/2/2018 17:01' prior: 33560395!lookup: arg1	"question, do we have to search in metaclass aswell?	answer might be later in the tutorial"	| Method Super|	Method:=self bodyOfMethod:arg1.	Method isNil	ifFalse:[		^Method."we found a corresponding selector"		].	"else"	"we do the lookup in the superclass."	((self objSuperclassId) isNil) "if we don't have a super class, we fail."	ifTrue:[		^nil.		].	Super:=self objSuperclass.	Super==self	ifTrue:[		^nil		].	^Super lookup:arg1.		! !----SNAPSHOT----2018-11-02T17:01:29.255977+01:00 Pharo6.1-64.image priorSource: 5272!!Obj methodsFor: 'message passing' stamp: 'pm 11/2/2018 17:09' prior: 33557667!send: arg1 withArguments: arg2	"or is it?"	Transcript show:arg1.	^self basicSend: arg1 withArguments: arg2 from: (self objClass).! !!Obj methodsFor: 'message passing' stamp: 'pm 11/2/2018 17:09' prior: 33561592!send: arg1 withArguments: arg2	"or is it?"	Transcript show:arg1;cr.	^self basicSend: arg1 withArguments: arg2 from: (self objClass).! !----SNAPSHOT----2018-11-02T17:09:57.159324+01:00 Pharo6.1-64.image priorSource: 6992!!Obj methodsFor: 'message passing' stamp: 'pm 11/2/2018 17:10' prior: 33561808!send: arg1 withArguments: arg2	"or is it?"	^self basicSend: arg1 withArguments: arg2 from: (self objClass).! !!Obj methodsFor: 'message passing' stamp: 'pm 11/2/2018 17:11' prior: 36307178!basicSend: arg1 withArguments: arg2 from: arg3	| tmp1 |	tmp1 := arg3 lookup: arg1.	Transcript show:tmp1;cr.	^ tmp1		ifNil: [ self sendError: arg1 withArgs: arg2 ]		ifNotNil: [ tmp1 valueWithArguments: (Array with: self) , arg2 ]! !!Obj methodsFor: 'message passing' stamp: 'pm 11/2/2018 17:14' prior: 33562307!basicSend: arg1 withArguments: arg2 from: arg3	| tmp1 |	tmp1 := arg3 lookup: arg1.	^ tmp1		ifNil: [ self sendError: arg1 withArgs: arg2 ]		ifNotNil: [ tmp1 valueWithArguments: (Array with: self) , arg2 ]! !!Obj methodsFor: 'message passing' stamp: 'pm 11/2/2018 17:15' prior: 36318139!sendError: arg1 withArgs: arg2	Transcript show:arg1;cr.		^ self send: #error withArguments: {(arg2 copyWithFirst: arg1)}! !!Obj methodsFor: 'message passing' stamp: 'pm 11/2/2018 17:32' prior: 33562917!sendError: arg1 withArgs: arg2	^ self send: #error withArguments: {(arg2 copyWithFirst: arg1)}! !!Obj methodsFor: 'message passing' stamp: 'pm 11/3/2018 11:26' prior: 33563124!sendError: arg1 withArgs: arg2	^ self send: #error withArguments: {(arg2 copyWithFirst: arg1)}! !!Obj methodsFor: 'message passing' stamp: 'pm 11/3/2018 11:28' prior: 33562625!basicSend: arg1 withArguments: arg2 from: arg3	| tmp1 |	tmp1 := arg3 lookup: arg1.	^ tmp1		ifNil: [ self sendError: arg1 withArgs: arg2 ]		ifNotNil: [ self halt.tmp1 valueWithArguments: (Array with: self) , arg2 ]! !!Obj methodsFor: 'message passing' stamp: 'pm 11/3/2018 11:32' prior: 33563483!basicSend: arg1 withArguments: arg2 from: arg3	| tmp1 |	tmp1 := arg3 lookup: arg1.	^ tmp1		ifNil: [ self sendError: arg1 withArgs: arg2 ]		ifNotNil: [ Transcript show:tmp1;cr.tmp1 valueWithArguments: (Array with: self) , arg2 ]! !!Obj methodsFor: 'message passing' stamp: 'pm 11/3/2018 11:34' prior: 33563785!basicSend: arg1 withArguments: arg2 from: arg3	| tmp1 |	tmp1 := arg3 lookup: arg1.	^ tmp1		ifNil: [ self sendError: arg1 withArgs: arg2 ]		ifNotNil: [ tmp1 valueWithArguments: (Array with: self) , arg2 ]! !!Obj methodsFor: 'message passing' stamp: 'pm 11/3/2018 11:34' prior: 33562114!send: arg1 withArguments: arg2	"or is it?"	self halt.	^self basicSend: arg1 withArguments: arg2 from: (self objClass).! !!Obj methodsFor: 'message passing' stamp: 'pm 11/3/2018 18:55' prior: 33564393!send: arg1 withArguments: arg2	"or is it?"	^self basicSend: arg1 withArguments: arg2 from: (self objClass).! !!Obj methodsFor: 'instance allocation' stamp: 'pm 11/3/2018 18:56' prior: 36335592!allocateAnInstance	| tmp1 tmp2 |	tmp1 := self class new: self numberOfIVs.	tmp1 at: (self offsetForName) put: self objName.	tmp2 := self numberOfIVs.	2 to: tmp2 do: [ :tmp3 | tmp1 at: tmp3 put: nil ].	^ tmp1! !!Obj methodsFor: 'instance allocation' stamp: 'pm 11/3/2018 18:58' prior: 33564795!allocateAnInstance	| tmp1 tmp2 |	tmp1 := (self class) new: self numberOfIVs.	tmp1 at: (self offsetForName) put: (self objName).	tmp2 := self numberOfIVs.	2 to: tmp2 do: [ :tmp3 | tmp1 at: tmp3 put: nil ].	^ tmp1! !!Obj methodsFor: 'message passing' stamp: 'pm 11/3/2018 19:01' prior: 33563304!sendError: arg1 withArgs: arg2	self halt.	^ self send: #error withArguments: {(arg2 copyWithFirst: arg1)}! !!Obj methodsFor: 'message passing' stamp: 'pm 11/3/2018 19:01' prior: 33565397!sendError: arg1 withArgs: arg2	^ self send: #error withArguments: {(arg2 copyWithFirst: arg1)}! !!Obj methodsFor: 'instance allocation' stamp: 'pm 11/3/2018 19:01' prior: 33565096!allocateAnInstance	| tmp1 tmp2 |	tmp1 := (self class) new: self numberOfIVs.	tmp1 at: 1 put: (self objName).	tmp2 := self numberOfIVs.	2 to: tmp2 do: [ :tmp3 | tmp1 at: tmp3 put: nil ].	^ tmp1! !!Obj methodsFor: 'instance allocation' stamp: 'pm 11/3/2018 19:04' prior: 33565771!allocateAnInstance	| tmp1 tmp2 |	tmp1 := (self class) new: self numberOfIVs.	tmp1 at: 1 put: (self objName).	tmp2 := self numberOfIVs.	2 to: tmp2 do: [ :tmp3 | tmp1 at: tmp3 put: nil ].	self halt.	^ tmp1! !!Obj methodsFor: 'instance allocation' stamp: 'pm 11/3/2018 19:08' prior: 33566057!allocateAnInstance	| tmp1 size |	size := self numberOfIVs.	tmp1 := (self class) new: size.	tmp1 at: 1 put: (self objName).	2 to: size do: [ :tmp3 | tmp1 at: tmp3 put: nil ].	^ tmp1! !!Obj methodsFor: 'message passing' stamp: 'pm 11/3/2018 19:24' prior: 33564598!send: arg1 withArguments: arg2	"or is it?"	^self basicSend: arg1 withArguments: arg2 from: self.! !!Obj methodsFor: 'message passing' stamp: 'pm 11/3/2018 19:26' prior: 33564101!basicSend: arg1 withArguments: arg2 from: arg3	| tmp1 |	tmp1 := arg3 lookup: arg1.	^tmp1		ifNil: [ self sendError: arg1 withArgs: arg2 ]		ifNotNil: [ tmp1 valueWithArguments: (Array with: self) , arg2 ]! !!Obj methodsFor: 'message passing' stamp: 'pm 11/3/2018 19:26' prior: 33566625!send: arg1 withArguments: arg2	"or is it?"	^self basicSend: arg1 withArguments: arg2 from: (self objClass).! !!Obj methodsFor: 'message passing' stamp: 'pm 11/3/2018 19:27' prior: 36318728!super: arg1 withArguments: arg2 from: arg3	self halt.! !!Obj methodsFor: 'message passing' stamp: 'pm 11/3/2018 19:27' prior: 33567291!super: arg1 withArguments: arg2 from: arg3	self halt.	^self! !!Obj methodsFor: 'message passing' stamp: 'pm 11/3/2018 19:28' prior: 33567429!super: arg1 withArguments: arg2 from: arg3	^self! !!Obj methodsFor: 'message passing' stamp: 'pm 11/3/2018 19:31' prior: 33565588!sendError: arg1 withArgs: arg2	self halt.	^ self send: #error withArguments: {(arg2 copyWithFirst: arg1)}! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/3/2018 19:36' prior: 33560952!lookup: arg1	"question, do we have to search in metaclass aswell?	answer might be later in the tutorial"	| Method Super|	Method:=self bodyOfMethod:arg1.	Method isNil	ifFalse:[		^Method."we found a corresponding selector"		].	"else"	"we do the lookup in the superclass."	((self objSuperclassId) isNil) "if we don't have a super class, we fail."	ifTrue:[		^nil.		].	Super:=self objSuperclass.	Super==self	ifTrue:[		^nil		].	^Super lookup:arg1.		! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/3/2018 19:37' prior: 33567897!lookup: arg1	"question, do we have to search in metaclass aswell?	answer might be later in the tutorial"	| Method Super|	Method:=self bodyOfMethod:arg1.	Method isNil	ifFalse:[		^Method."we found a corresponding selector"		].	"else"	"we do the lookup in the superclass."	Super:=self objSuperclass.	(Super isNil) "if we don't have a super class, we fail."	ifTrue:[		^nil.		].	Super==self	ifTrue:[		^nil		].	^Super lookup:arg1.		! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/3/2018 19:37' prior: 33568448!lookup: arg1	"question, do we have to search in metaclass aswell?	answer might be later in the tutorial"	| Method Super|	Method:=self bodyOfMethod:arg1.	Method isNil	ifFalse:[		^Method."we found a corresponding selector"		].	"else"	"we do the lookup in the superclass."	Super:=self objSuperclass.	(Super isNil) "if we don't have a super class, we fail."	ifTrue:[		^nil.		].	Super==self	ifTrue:[		^nil		].	^Super lookup:arg1.		! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/3/2018 19:39' prior: 33568983!lookup: arg1	"question, do we have to search in metaclass aswell?	answer might be later in the tutorial"	| Method Super|	Method:=self bodyOfMethod:arg1.	Method isNil	ifFalse:[		^Method."we found a corresponding selector"		].	"else"	"we do the lookup in the superclass."	Super:=self objSuperclass.	(self objSuperclass isNil or:[Super==self]) "if we don't have a super class, we fail."	ifTrue:[		^nil.		].	^Super lookup:arg1.		! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/3/2018 19:39' prior: 33569517!lookup: arg1	"question, do we have to search in metaclass aswell?	answer might be later in the tutorial"	| Method Super|	Method:=self bodyOfMethod:arg1.	Method isNil	ifFalse:[		^Method."we found a corresponding selector"		].	"else"	"we do the lookup in the superclass."	Super:=self objSuperclass.	(self objSuperclass isNil or:[Super==self]) "if we don't have a super class, we fail."	ifTrue:[		^nil.		].		^Super lookup:arg1.		! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/3/2018 19:41' prior: 33570045!lookup: arg1	"question, do we have to search in metaclass aswell?	answer might be later in the tutorial"	| Method Super|	Method:=self bodyOfMethod:arg1.	Method isNil	ifFalse:[		^Method."we found a corresponding selector"		].	"else"	"we do the lookup in the superclass."	Super:=self objSuperclassId.	(Super~=nil or:[Super==self]) "if we don't have a super class, we fail."	ifTrue:[		^nil.		].	^Super lookup:arg1.		! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/3/2018 19:42' prior: 33570575!lookup: arg1	"question, do we have to search in metaclass aswell?	answer might be later in the tutorial"	| Method Super|	Method:=self bodyOfMethod:arg1.	Method isNil	ifFalse:[		^Method."we found a corresponding selector"		].	"else"	"we do the lookup in the superclass."	Super:=self objSuperclassId.	(Super~=#nil or:[Super==self]) "if we don't have a super class, we fail."	ifTrue:[		^nil.		].	^Super lookup:arg1.		! !!Obj methodsFor: 'message passing' stamp: 'pm 11/3/2018 19:42' prior: 33567708!sendError: arg1 withArgs: arg2	^ self send: #error withArguments: {(arg2 copyWithFirst: arg1)}! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/3/2018 19:43' prior: 33571091!lookup: arg1	"question, do we have to search in metaclass aswell?	answer might be later in the tutorial"	| Method Super|	Method:=self bodyOfMethod:arg1.	Method isNil	ifFalse:[		^Method."we found a corresponding selector"		].	"else"	"we do the lookup in the superclass."	Super:=self objSuperclassId.	(Super~=#nil or:[self objSuperclassId==self]) "if we don't have a super class, we fail."	ifTrue:[		^nil.		].	^Super lookup:arg1.		! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/3/2018 19:55' prior: 33571787!lookup: arg1	"question, do we have to search in metaclass aswell?	answer might be later in the tutorial"	| Method Super|	Method:=self bodyOfMethod:arg1.	Method isNil	ifFalse:[		^Method."we found a corresponding selector"		].	"else"	"we do the lookup in the superclass."	Super:=self objSuperclassId.	Transcript show: Super.	self halt.	(Super~=#nil or:[self objSuperclassId==self]) "if we don't have a super class, we fail."	ifTrue:[		^nil.		].	^Super lookup:arg1.		! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/3/2018 19:56' prior: 33572319!lookup: arg1	"question, do we have to search in metaclass aswell?	answer might be later in the tutorial"	| Method Super|	Method:=self bodyOfMethod:arg1.	Method isNil	ifFalse:[		^Method."we found a corresponding selector"		].	"else"	"we do the lookup in the superclass."	Super:=self objSuperclassId.	Transcript show: Super.	self halt.	(Super~=#nil or:[self objSuperclass==self]) "if we don't have a super class, we fail."	ifTrue:[		^nil.		].	^Super lookup:arg1.		! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/3/2018 20:07' prior: 33572888!lookup: arg1	"question, do we have to search in metaclass aswell?	answer might be later in the tutorial"	| Method Super|	Method:=self bodyOfMethod:arg1.	Method isNil	ifFalse:[		^Method."we found a corresponding selector"		].	"else"	"we do the lookup in the superclass."	Super:=self objSuperclassId.	Transcript show: Super;cr.	self halt.	(Super~=#nil or:[self objSuperclass==self]) "if we don't have a super class, we fail."	ifTrue:[		^nil.		].	^Super lookup:arg1.		! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/3/2018 20:08' prior: 33573455!lookup: arg1	"question, do we have to search in metaclass aswell?	answer might be later in the tutorial"	| Method Super|	Method:=self bodyOfMethod:arg1.	Method isNil	ifFalse:[		^Method."we found a corresponding selector"		].	"else"	"we do the lookup in the superclass."	Super:=self objSuperclass.	Transcript show: Super;cr.	self halt.	(Super~=nil or:[self objSuperclass==self]) "if we don't have a super class, we fail."	ifTrue:[		^nil.		].	^Super lookup:arg1.		! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/3/2018 20:12' prior: 33574025!lookup: arg1	"question, do we have to search in metaclass aswell?	answer might be later in the tutorial"	| Method Super|	Method:=self bodyOfMethod:arg1.	Method isNil	ifFalse:[		^Method."we found a corresponding selector"		].	"else"	"we do the lookup in the superclass."	Super:=self objSuperclass.	Transcript show: Super;cr;cr.	self halt.	(Super~=nil or:[self objSuperclass==self]) "if we don't have a super class, we fail."	ifTrue:[		^nil.		].	^Super lookup:arg1.		! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/3/2018 20:12' prior: 33574592!lookup: arg1	"question, do we have to search in metaclass aswell?	answer might be later in the tutorial"	| Method Super|	Method:=self bodyOfMethod:arg1.	Method isNil	ifFalse:[		^Method."we found a corresponding selector"		].	"else"	"we do the lookup in the superclass."	Super:=self objSuperclass.	Transcript show: Super;cr;cr.	self halt.	(Super~=nil or:[Super==self]) "if we don't have a super class, we fail."	ifTrue:[		^nil.		].	^Super lookup:arg1.		! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/3/2018 20:12' prior: 33575162!lookup: arg1	"question, do we have to search in metaclass aswell?	answer might be later in the tutorial"	| Method Super|	Method:=self bodyOfMethod:arg1.	Method isNil	ifFalse:[		^Method."we found a corresponding selector"		].	"else"	"we do the lookup in the superclass."	Super:=self objSuperclass.	Transcript show: Super;cr;cr.	self halt.	(Super isNil or:[Super==self]) "if we don't have a super class, we fail."	ifTrue:[		^nil.		].	^Super lookup:arg1.		! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/3/2018 20:13' prior: 33575719!lookup: arg1	"question, do we have to search in metaclass aswell?	answer might be later in the tutorial"	| Method Super|	Method:=self bodyOfMethod:arg1.	Method isNil	ifFalse:[		^Method."we found a corresponding selector"		].	"else"	"we do the lookup in the superclass."	Super:=self objSuperclass.	Transcript show: Super;cr;cr.	(Super isNil or:[Super==self]) "if we don't have a super class, we fail."	ifTrue:[		^nil.		].	^Super lookup:arg1.		! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/3/2018 20:19' prior: 33576277!lookup: arg1	"question, do we have to search in metaclass aswell?	answer might be later in the tutorial"	| Method Super|	Method:=self bodyOfMethod:arg1.	Method isNil	ifFalse:[		^Method."we found a corresponding selector"		].	"else"	"we do the lookup in the superclass."	Super:=self objSuperclass.	Transcript show: Super getClass ;cr;cr.	(Super isNil or:[Super==self]) "if we don't have a super class, we fail."	ifTrue:[		^nil.		].	^Super lookup:arg1.		! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/3/2018 20:20' prior: 33576823!lookup: arg1	"question, do we have to search in metaclass aswell?	answer might be later in the tutorial"	| Method Super|	Method:=self bodyOfMethod:arg1.	Method isNil	ifFalse:[		^Method."we found a corresponding selector"		].	"else"	"we do the lookup in the superclass."	Super:=self objSuperclass.	Transcript show: Super ;cr;cr.	(Super isNil or:[Super==self]) "if we don't have a super class, we fail."	ifTrue:[		^nil.		].	^Super lookup:arg1.		! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/3/2018 20:21' prior: 33577379!lookup: arg1	"question, do we have to search in metaclass aswell?	answer might be later in the tutorial"	| Method Super|	Method:=self bodyOfMethod:arg1.	Method isNil	ifFalse:[		^Method."we found a corresponding selector"		].	"else"	"we do the lookup in the superclass."	Transcript show: Super ;cr;cr.	(self objSuperclassId isNil or:[	Super:=self objSuperclass.Super==self]) "if we don't have a super class, we fail."	ifTrue:[		^nil.		].	^Super lookup:arg1.		! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/3/2018 20:24' prior: 33577926!lookup: arg1	"question, do we have to search in metaclass aswell?	answer might be later in the tutorial"	| Method Super|	Method:=self bodyOfMethod:arg1.	Method isNil	ifFalse:[		^Method."we found a corresponding selector"		].	"else"	"we do the lookup in the superclass."	(self objSuperclass isNil 		or:[Super:=self objSuperclass.			Super==self]) "if we don't have a super class, we fail."	ifTrue:[		^nil.		].	^Super lookup:arg1.		! !----QUIT/NOSAVE----2018-11-03T20:25:58.225322+01:00 Pharo6.1-64.image priorSource: 7514!!Obj methodsFor: 'message passing' stamp: 'pm 11/3/2018 20:26' prior: 33561808!send: arg1 withArguments: arg2	"or is it?"	^self basicSend: arg1 withArguments: arg2 from: (self objClass).! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/3/2018 20:27' prior: 33560952!lookup: arg1	"question, do we have to search in metaclass aswell?	answer might be later in the tutorial"	| Method Super|	Method:=self bodyOfMethod:arg1.	Method isNil	ifFalse:[		^Method."we found a corresponding selector"		].	"else"	"we do the lookup in the superclass."	"if we don't have a super class, we fail."	"((self objSuperclassId) isNil) 	ifTrue:[		^nil.		]."	Super:=self objSuperclass.	Super==self	ifTrue:[		^nil		].	^Super lookup:arg1.		! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/3/2018 20:27' prior: 33579305!lookup: arg1	"question, do we have to search in metaclass aswell?	answer might be later in the tutorial"	| Method Super|	Method:=self bodyOfMethod:arg1.	Method isNil	ifFalse:[		^Method."we found a corresponding selector"		].	"else"	"we do the lookup in the superclass."	"if we don't have a super class, we fail."	((self objSuperclassId) isNil) 	ifTrue:[		^nil.		].	Super:=self objSuperclass.	Super==self	ifTrue:[		^nil		].	^Super lookup:arg1.		! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/3/2018 20:27' prior: 33579861!lookup: arg1	"question, do we have to search in metaclass aswell?	answer might be later in the tutorial"	| Method Super|	Method:=self bodyOfMethod:arg1.	Method isNil	ifFalse:[		^Method."we found a corresponding selector"		].	"else"	"we do the lookup in the superclass."	((self objSuperclassId) isNil) "if we don't have a super class, we fail."	ifTrue:[		^nil.		].	Super:=self objSuperclass.	Super==self	ifTrue:[		^nil		].	^Super lookup:arg1.		! !!ObjTest methodsFor: 'tests' stamp: 'pm 11/3/2018 20:29' prior: 36274658!testMethodLookup	Transcript show:((pointClass lookup: #x) isKindOf: BlockClosure)	self assert: ((pointClass lookup: #x) isKindOf: BlockClosure)! !!ObjTest methodsFor: 'tests' stamp: 'pm 11/3/2018 20:29' prior: 33580963!testMethodLookup	Transcript show:((pointClass lookup: #x) isKindOf: BlockClosure).	self assert: ((pointClass lookup: #x) isKindOf: BlockClosure)! !!ObjTest methodsFor: 'tests' stamp: 'pm 11/3/2018 20:30' prior: 33581186!testMethodLookup	Transcript show:(pointClass lookup: #x).	self assert: ((pointClass lookup: #x) isKindOf: BlockClosure)! !!Obj methodsFor: 'method management' stamp: 'pm 11/3/2018 20:30' prior: 33556081!bodyOfMethod: arg1	^self objMethodDict at: arg1 ifAbsent: [ nil ].! !!ObjTest methodsFor: 'tests' stamp: 'pm 11/3/2018 20:31' prior: 33581410!testMethodLookup	self assert: ((pointClass lookup: #x) isKindOf: BlockClosure)! !!Obj methodsFor: 'message passing' stamp: 'pm 11/3/2018 20:33' prior: 36318728!super: arg1 withArguments: arg2 from: arg3	^self	! !!Obj methodsFor: 'message passing' stamp: 'pm 11/3/2018 20:36' prior: 33581925!super: arg1 withArguments: arg2 from: arg3	! !!Obj methodsFor: 'message passing' stamp: 'pm 11/3/2018 20:38' prior: 33582060!super: arg1 withArguments: arg2 from: arg3	| Super |		((self objSuperclassId) isNil) "if we don't have a super class, we fail."	ifTrue:[		^nil.		].	Super:=self objSuperclass.	Super==self	ifTrue:[		^nil		].	^Super basicSend: arg1 withArguments: arg2 from: arg3.! !!Obj methodsFor: 'message passing' stamp: 'pm 11/3/2018 20:51' prior: 33582189!super: arg1 withArguments: arg2 from: arg3	^self objSuperclass basicSend: arg1 withArguments: arg2 from: arg3.! !!Obj methodsFor: 'message passing' stamp: 'pm 11/3/2018 20:53' prior: 33582549!super: arg1 withArguments: arg2 from: arg3	^(self objClass) objSuperclass basicSend: arg1 withArguments: arg2 from: arg3.! !!Obj methodsFor: 'message passing' stamp: 'pm 11/3/2018 20:53' prior: 33582747!super: arg1 withArguments: arg2 from: arg3	^(self objClass) objSuperclass basicSend: arg1 withArguments: arg2 from: arg3.! !!Obj methodsFor: 'iv management' stamp: 'pm 11/3/2018 20:56' prior: 36331334!valueOfInstanceVariable: arg1	| tmp1 |	tmp1 := self offsetFromObjectOfInstanceVariable: arg1.	tmp1 ~= 0		ifTrue: [ ^ self at: tmp1 ].	^ Error signal.! !!Obj methodsFor: 'iv management' stamp: 'pm 11/3/2018 20:59' prior: 33583161!valueOfInstanceVariable: arg1	| tmp1 |	tmp1 := self offsetFromObjectOfInstanceVariable: arg1.	tmp1 ~= 0		ifTrue: [ ^ self at: tmp1 ].	Error signal.! !!Obj methodsFor: 'iv management' stamp: 'pm 11/3/2018 21:00' prior: 33583397!valueOfInstanceVariable: arg1	| tmp1 |	tmp1 := self offsetFromObjectOfInstanceVariable: arg1.	Transcript show: self.	tmp1 ~= 0		ifTrue: [ ^ self at: tmp1 ].	Error signal.! !!Obj methodsFor: 'iv management' stamp: 'pm 11/3/2018 21:00' prior: 33583631!valueOfInstanceVariable: arg1	| tmp1 |	tmp1 := self offsetFromObjectOfInstanceVariable: arg1.	self halt.	tmp1 ~= 0		ifTrue: [ ^ self at: tmp1 ].	Error signal.! !!Obj methodsFor: 'iv management' stamp: 'pm 11/3/2018 21:00' prior: 33583889!valueOfInstanceVariable: arg1	| tmp1 |	tmp1 := self offsetFromObjectOfInstanceVariable: arg1.	tmp1 ~= 0		ifTrue: [ ^ self at: tmp1 ].! !!Obj methodsFor: 'iv management' stamp: 'pm 11/3/2018 21:31' prior: 36329974!offsetFromObjectOfInstanceVariable: arg1	| t |	t:=self objClass offsetFromClassOfInstanceVariable: arg1.	^t==0		ifTrue:[^self error:'']		ifFalse:[t].! !----SNAPSHOT----2018-11-03T21:37:11.766738+01:00 Pharo6.1-64.image priorSource: 7514!----SNAPSHOT----2018-11-03T21:37:31.262106+01:00 Pharo6.1-64.image priorSource: 30080!----QUIT----2018-11-03T21:38:26.188203+01:00 Pharo6.1-64.image priorSource: 30167!TestCase variableSubclass: #ObjExampleTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ObjVSkeleton-AdvancedTests'!!ObjExampleTest methodsFor: 'test abstract' stamp: '' prior: 36256159!testAbstractMetaclassExampleWithConcreteSubclass	self		shouldnt: [ Obj ObjPoint send: #new withArguments: #(#(#x: 24 #y: 6)) ]		raise: Error! !!ObjExampleTest methodsFor: 'test abstract' stamp: '' prior: 36256390!testColoredPoint	| tmp1 tmp2 |	tmp1 := Obj ObjClass		send: #new		withArguments: #(#(#name: #ObjColoredPoint #iv: #(#color) #superclass: #ObjPoint)).	tmp2 := tmp1		send: #new		withArguments: #(#(#x: 24 #y: 6 #color: #blue)).	self assert: (tmp2 send: #getIV withArguments: #(#x)) = 24.	tmp2 send: #setIV withArguments: #(#x 25).	self		assert: (tmp2 send: #getIV withArguments: #(#x)) = 25;		assert: (tmp2 send: #getIV withArguments: #(#color)) = #blue.	tmp1		addUnaryMethod: #giveColor			withBody: 'objself send: #getIV withArguments: #(#color)';		addMethod: #setColor			args: 'col'			withBody: ' objself send: #setIV withArguments: (Array with: #color with: col)';		addUnaryMethod: #display			withBody:			'objself super: #display withArguments: #() from: superClassOfClassDefiningTheMethod.			Transcript cr;				show: '' with Color = ''.			Transcript show: (objself send: #giveColor withArguments: #()) printString;				cr'.	self		assert: (tmp2 send: #giveColor withArguments: #()) = #blue;		assert: (tmp2 send: #givex withArguments: #()) = 25.	tmp2 send: #display withArguments: #()! !!ObjExampleTest methodsFor: 'test abstract' stamp: '' prior: 36255985!testAbstractMetaclassExample	self		should: [ Obj ObjAbstractClass send: #new withArguments: #(#(#x: 24 #y: 6)) ]		raise: Error! !!ObjExampleTest methodsFor: 'setup' stamp: '' prior: 36255662!defineObjPoint	Obj ObjClass		send: #new		withArguments: #(#(#name: #ObjPoint #iv: #(#x #y) #superclass: #ObjAbstractPoint))! !!ObjExampleTest methodsFor: 'setup' stamp: '' prior: 36255181!defineObjAbstractPoint	Obj ObjAbstractClass		send: #new		withArguments: #(#(#name: #ObjAbstractPoint #iv: #() #superclass: #ObjObject)).	Obj ObjAbstractPoint		addUnaryMethod: #givex			withBody: 'objself  valueOfInstanceVariable: #x ';		addUnaryMethod: #display			withBody:			'Transcript cr;				show: ''aPoint with x = ''.			Transcript show: (objself send: #givex withArguments: #()) printString;				cr'! !!ObjExampleTest methodsFor: 'setup' stamp: '' prior: 36255828!setUp	Obj bootstrap.	self		abstractMetaclassDefinition;		defineObjAbstractPoint;		defineObjPoint! !!ObjExampleTest methodsFor: 'setup' stamp: '' prior: 36254774!abstractMetaclassDefinition	(Obj giveClassNamed: #ObjClass)		send: #new		withArguments: #(#(#name: #ObjAbstractClass #iv: #() #superclass: #ObjClass)).	Obj ObjAbstractClass		addMethod: #new		args: 'initArray'		withBody: ' objself error: '' the class '' , objself objName asString , '' is abstract'''! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ObjExampleTest class	instanceVariableNames: ''!!ObjExampleTest class methodsFor: 'first user-defined metaclasses' stamp: '' prior: 36254326!setMetaclassExample	| tmp1 |	self setMetaclassDefinition.	tmp1 := Obj ObjSet		send: #new		withArguments: #(#(#name: #ObjMemoPoint #iv: #() #superclass: #ObjPoint)).	tmp1		send: #new withArguments: #(#(#x: 24 #y: 6));		send: #new withArguments: #(#(#x: 15 #y: 10)).	^ tmp1 send: #instances withArguments: #()! !!ObjExampleTest class methodsFor: 'first user-defined metaclasses' stamp: '' prior: 36253227!setMetaclassDefinition	| tmp1 |	tmp1 := Obj ObjClass		send: #new		withArguments: #(#(#name: #ObjSet #iv: #(#myInstances) #superclass: #ObjClass)).	tmp1		addMethod: #initialize			args: 'initArray'			withBody:			'			objself binarySuper: #initialize with: initArray from: superClassOfClassDefiningTheMethod.			objself send: #setIV				withArguments: (Array with: #myInstances with: OrderedCollection new).			objself';		addUnaryMethod: #instances			withBody: 'objself binarySend: #getIV with: #myInstances';		addMethod: #new			args: 'initArray'			withBody:			'| newInst others |			newInst := objself super: #new withArguments: (Array with: initArray) from: superClassOfClassDefiningTheMethod.			others := objself unarySend: #instances.			others := others add: newInst;						yourself.			objself send: #setIV withArguments: (Array with: #myInstances with: others).			newInst'! !TestCase subclass: #ObjTestBootstrap	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ObjVSkeleton-AdvancedTests'!!ObjTestBootstrap methodsFor: 'test ObjObject creation ' stamp: '' prior: 36285706!testCreateObjObjectMessage	| tmp1 |	Obj		initialize;		manuallyCreateObjClass;		createObjObject.	tmp1 := Obj giveClassNamed: #ObjObject.	self		assert:			(tmp1 send: #class withArguments: #())				= (Obj giveClassNamed: #ObjClass);		assert: (tmp1 send: #isClass withArguments: #()) not;		assert: (tmp1 send: #getIV withArguments: #(#class)) = #ObjClass! !!ObjTestBootstrap methodsFor: 'test ObjObject creation ' stamp: '' prior: 36284914!testCreateObjObjectInstanceMessage	| tmp1 tmp2 tmp3 |	Obj		initialize;		manuallyCreateObjClass;		createObjObject.	tmp2 := Obj giveClassNamed: #ObjClass.	tmp1 := tmp2		send: #new		withArguments: #(#(#name: #ObjPoint #superclass: #ObjObject #iv: #(#x #y))).	tmp3 := tmp1 send: #new withArguments: #(#()).	self		assert: tmp3 objClassId = #ObjPoint;		assert: (tmp3 send: #getIV withArguments: #(#x)) = nil.	tmp3 send: #setIV withArguments: #(#x 25).	self assert: (tmp3 send: #getIV withArguments: #(#x)) = 25! !!ObjTestBootstrap methodsFor: 'test ObjObject creation ' stamp: '' prior: 36286252!testCreateObjObjectStructure	| tmp1 |	Obj		initialize;		manuallyCreateObjClass;		createObjObject.	tmp1 := Obj giveClassNamed: #ObjObject.	self		assert: tmp1 objName = #ObjObject;		assert: tmp1 objClassId = #ObjClass;		assert: tmp1 objSuperclassId isNil;		assert: tmp1 objIVs asArray = #(#class);		assert: tmp1 objKeywords asArray = #()! !!ObjTestBootstrap methodsFor: 'test ObjClass manual creation ' stamp: '' prior: 36286827!testManuallyCreateObjClassAllocate	| tmp1 tmp2 |	Obj		initialize;		manuallyCreateObjClass.	tmp1 := Obj giveClassNamed: #ObjClass.	tmp2 := tmp1 send: #allocate withArguments: #().	self		assert: tmp2 objClassId = #ObjClass;		assert: tmp2 objSuperclassId isNil;		assert: tmp2 objIVs isNil;		assert: tmp2 objKeywords isNil;		assert: tmp2 objMethodDict isNil;		assert: tmp2 objName isNil! !!ObjTestBootstrap methodsFor: 'test ObjClass manual creation ' stamp: '' prior: 36287477!testManuallyCreateObjClassStructure	| tmp1 |	Obj		initialize;		manuallyCreateObjClass.	tmp1 := Obj giveClassNamed: #ObjClass.	self		assert: tmp1 objName = #ObjClass;		assert: tmp1 objClassId = #ObjClass;		assert: tmp1 objClass == tmp1;		assert: tmp1 objSuperclassId = #ObjObject;		assert: tmp1 objIVs = #(#class #name #superclass #iv #keywords #methodDict);		assert: tmp1 objKeywords = #(#name: #superclass: #iv: #keywords: #methodDict:)! !!ObjTestBootstrap methodsFor: 'test ObjClass creation' stamp: '' prior: 36284309!testCreateObjClassStructure	| tmp1 |	Obj bootstrap.	tmp1 := Obj giveClassNamed: #ObjClass.	self		assert: tmp1 objName = #ObjClass;		assert: tmp1 objClassId = #ObjClass;		assert: tmp1 objSuperclassId = #ObjObject;		assert:			tmp1 objIVs asArray				= #(#class #name #superclass #iv #keywords #methodDict);		assert:			tmp1 objKeywords asArray				= #(#name: #superclass: #iv: #keywords: #methodDict:)! !!ObjTestBootstrap methodsFor: 'test ObjClass creation' stamp: '' prior: 36283839!testCreateObjClassMessage	| tmp1 |	Obj bootstrap.	tmp1 := Obj giveClassNamed: #ObjClass.	self		assert:			(tmp1 send: #class withArguments: #())				= (Obj giveClassNamed: #ObjClass);		assert: (tmp1 send: #isClass withArguments: #());		assert: (tmp1 send: #isMetaclass withArguments: #())! !EyeCollectionInspector variableSubclass: #ObjClassInspector	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ObjVSkeleton-Inspector'!!ObjClassInspector methodsFor: 'list' stamp: '' prior: 36319647!addVariableFields: arg1	| tmp1 |	tmp1 := Obj classInstanceVariables.	tmp1		do: [ :arg2 | 			| tmp3 |			tmp3 := StrictlyOrderedEyeElement new.			tmp3				orderedStructure: tmp1;				host: self object;				index: arg2.			arg1 add: tmp3 yourself ]! !BasicIndexedEyeElement variableSubclass: #StrictlyOrderedEyeElement	instanceVariableNames: 'orderedStructure'	classVariableNames: ''	poolDictionaries: ''	category: 'ObjVSkeleton-Inspector'!!StrictlyOrderedEyeElement methodsFor: 'accessing' stamp: '' prior: 36319204!orderedStructure	^ orderedStructure! !!StrictlyOrderedEyeElement methodsFor: 'accessing' stamp: '' prior: 36319340!orderedStructure: arg1	orderedStructure := arg1! !!StrictlyOrderedEyeElement methodsFor: 'accessing' stamp: '' prior: 36319496!value	^ self host basicAt: (self orderedStructure indexOf: index)! !TestCase subclass: #ObjMessageTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ObjVSkeleton-Experimental'!!ObjMessageTest methodsFor: 'setup' stamp: '' prior: 36257870!setUp	Obj		bootstrap;		objClassStructureMessage! !!ObjMessageTest methodsFor: 'tests' stamp: '' prior: 36258953!testMessageClassStructureDeclared	Obj objClassStructureMessage.	self		assert: Obj ObjMessage objName = #ObjMessage;		assert: Obj ObjMessage objClass objName = #ObjClass;		assert:			Obj ObjMessage objIVs asArray				= #(#class #receiver #selector #arguments);		assert: Obj ObjMessage objSuperclass = Obj ObjObject! !!ObjMessageTest methodsFor: 'tests' stamp: '' prior: 36258694!testMessageClassMethodsDefined	| tmp1 |	Obj addMessagesForErrorHandling.	self deny: Obj ObjMessage objMethodDict size isZero! !!ObjMessageTest methodsFor: 'tests' stamp: '' prior: 36258006!testMessageClassMethods	| tmp1 |	Obj addMessagesForErrorHandling.	tmp1 := Obj ObjMessage		send: #new		withArguments: #(#(#receiver: 24 #selector: #factorial)).	self		assert: (tmp1 send: #receiver2 withArguments: #()) equals: 24;		assert: (tmp1 send: #receiver withArguments: #()) equals: 24;		assert: (tmp1 send: #selector withArguments: #())			equals: #factorial.	tmp1 := Obj ObjMessage		send: #new		withArguments: #(#(#receiver: 24 #selector: #+ #arguments: #(25))).	self assert: (tmp1 send: #arguments withArguments: #()) equals: #(25)! !!ObjMessageTest methodsFor: 'tests' stamp: '' prior: 36259360!testUsingPrimitivesMessageClassMethods	| tmp1 |	tmp1 := Obj ObjMessage		send: #new		withArguments: #(#(#receiver: 24 #selector: #factorial)).	self		assert: (tmp1 at: 1) equals: #ObjMessage;		assert: (tmp1 at: 2) equals: 24;		assert: (tmp1 at: 3) equals: #factorial.	tmp1 := Obj ObjMessage		send: #new		withArguments: #(#(#receiver: 24 #selector: #+ #arguments: #(25))).	self assert: (tmp1 at: 4) equals: #(25)! !Array variableSubclass: #Obj	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ObjVSkeleton'!!Obj methodsFor: 'class structure offset' stamp: '' prior: 36315650!offsetForIVs	^ 4! !!Obj methodsFor: 'class structure offset' stamp: '' prior: 36315862!offsetForMethodDict	^ 6! !!Obj methodsFor: 'class structure offset' stamp: '' prior: 36315973!offsetForName	^ 2! !!Obj methodsFor: 'class structure offset' stamp: '' prior: 36316078!offsetForSuperclass	^ 3! !!Obj methodsFor: 'class structure offset' stamp: '' prior: 36315753!offsetForKeywords	^ 5! !!Obj methodsFor: 'printing' stamp: '' prior: 36316795!printOn: arg1	arg1 nextPutAll: 'an Obj object: '.	super printOn: arg1! !!Obj methodsFor: 'object structure primitive' stamp: '' prior: 36324183!objClassId	^ self at: self offsetForClass! !!Obj methodsFor: 'object structure primitive' stamp: '' prior: 36324509!objClassId: arg1	self at: self offsetForClass put: arg1! !!Obj methodsFor: 'object structure primitive' stamp: '' prior: 36326914!objClass	^ self class giveClassNamed: self objClassId! !!Obj methodsFor: 'instance allocation' stamp: '' prior: 36335592!allocateAnInstance	| tmp1 tmp2 |	tmp1 := self class new: self numberOfIVs.	tmp1 at: 1 put: self objName.	tmp2 := self numberOfIVs.	2 to: tmp2 do: [ :tmp3 | tmp1 at: tmp3 put: nil ].	^ tmp1! !!Obj methodsFor: 'debugging' stamp: '' prior: 36308267!classDebug	ObjClassInspector basicInspect: self! !!Obj methodsFor: 'iv inheritance' stamp: '' prior: 36309331!computeNewIVFromClass: arg1 with: arg2	| tmp1 |	^ arg1 isNil		ifTrue: [ arg2 ]		ifFalse: [ tmp1 := arg1 objIVs asOrderedCollection copy.			arg2				do: [ :arg3 | 					(tmp1 includes: arg3)						ifFalse: [ tmp1 add: arg3 ] ].			tmp1 ]! !!Obj methodsFor: 'iv inheritance' stamp: '' prior: 36308836!computeNewIVFrom: arg1 with: arg2	| tmp1 |	^ arg1 isNil		ifTrue: [ arg2 ]		ifFalse: [ tmp1 := arg1 asOrderedCollection copy.			arg2				do: [ :arg3 | 					(tmp1 includes: arg3)						ifFalse: [ tmp1 add: arg3 ] ].			tmp1 ]! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/3/2018 20:27' prior: 33580415!lookup: arg1	"question, do we have to search in metaclass aswell?	answer might be later in the tutorial"	| Method Super|	Method:=self bodyOfMethod:arg1.	Method isNil	ifFalse:[		^Method."we found a corresponding selector"		].	"else"	"we do the lookup in the superclass."	((self objSuperclassId) isNil) "if we don't have a super class, we fail."	ifTrue:[		^nil.		].	Super:=self objSuperclass.	Super==self	ifTrue:[		^nil		].	^Super lookup:arg1.		! !!Obj methodsFor: 'object structure offset' stamp: '' prior: 36315544!offsetForClass	^ 1! !!Obj methodsFor: 'message passing' stamp: '' prior: 36307178!basicSend: arg1 withArguments: arg2 from: arg3	| tmp1 |	tmp1 := arg3 lookup: arg1.	^ tmp1		ifNil: [ self sendError: arg1 withArgs: arg2 ]		ifNotNil: [ tmp1 valueWithArguments: (Array with: self) , arg2 ]! !!Obj methodsFor: 'message passing' stamp: '' prior: 36318139!sendError: arg1 withArgs: arg2	^ self send: #error withArguments: {(arg2 copyWithFirst: arg1)}! !!Obj methodsFor: 'message passing' stamp: 'pm 11/3/2018 20:53' prior: 33582956!super: arg1 withArguments: arg2 from: arg3	^(self objClass) objSuperclass basicSend: arg1 withArguments: arg2 from: arg3.! !!Obj methodsFor: 'message passing' stamp: 'pm 11/3/2018 20:26' prior: 33579114!send: arg1 withArguments: arg2	"or is it?"	^self basicSend: arg1 withArguments: arg2 from: (self objClass).! !!Obj methodsFor: 'method management' stamp: '' prior: 36316959!removeMethod: arg1	self objMethodDict removeKey: arg1 ifAbsent: [  ]! !!Obj methodsFor: 'method management' stamp: '' prior: 36311570!methodWithHeader: arg1 andBody: arg2	| tmp1 tmp2 tmp3 |	tmp2 := self stringOfBlockBodyFromHeader: arg1 andBody: arg2.	tmp1 := Compiler evaluate: tmp2.	tmp3 := tmp1		value: (Obj giveClassNamed: self objSuperclassId ifAbsent: [ 666 ]).	^ tmp3! !!Obj methodsFor: 'method management' stamp: '' prior: 36306531!addUnaryMethod: arg1 withBody: arg2	self addMethod: arg1 args: '' withBody: arg2! !!Obj methodsFor: 'method management' stamp: 'pm 11/3/2018 20:30' prior: 33581617!bodyOfMethod: arg1	^self objMethodDict at: arg1 ifAbsent: [ nil ].! !!Obj methodsFor: 'method management' stamp: '' prior: 36307693!blockArgsFrom: arg1	| tmp1 tmp3 |	tmp1 := arg1 findTokens: Character space.	tmp1 := tmp1 copyWithout: ''.	tmp3 := ''.	tmp1		do: [ :arg2 | tmp3 := tmp3 , ':' , arg2 ]		separatedBy: [ tmp3 := tmp3 , ' ' ].	^ tmp3! !!Obj methodsFor: 'method management' stamp: '' prior: 36318479!stringOfBlockBodyFromHeader: arg1 andBody: arg2	^ '[ :superClassOfClassDefiningTheMethod |		[ :objself ' , (self blockArgsFrom: arg1)		,			' |					 ' , arg2 , '] ]'! !!Obj methodsFor: 'method management' stamp: '' prior: 36306005!addMethod: arg1 args: arg2 withBody: arg3	self objMethodDict		at: arg1		put: (self methodWithHeader: arg2 andBody: arg3)! !!Obj methodsFor: 'method management' stamp: '' prior: 36309774!doesUnderstand: arg1	^ self objMethodDict keys includes: arg1! !!Obj methodsFor: 'iv management' stamp: '' prior: 36330853!offsetFromClassOfInstanceVariable: arg1	| tmp2 |	tmp2 := self numberOfIVs.	1 to: tmp2 do: [ :tmp1 | 		arg1 = (self objIVs at: tmp1)			ifTrue: [ ^ tmp1 ] ].	^ 0! !!Obj methodsFor: 'iv management' stamp: '' prior: 36311987!numberOfIVs	^ self objIVs size! !!Obj methodsFor: 'iv management' stamp: 'pm 11/3/2018 21:00' prior: 33584135!valueOfInstanceVariable: arg1	| tmp1 |	tmp1 := self offsetFromObjectOfInstanceVariable: arg1.	tmp1 ~= 0		ifTrue: [ ^ self at: tmp1 ].! !!Obj methodsFor: 'iv management' stamp: 'pm 11/3/2018 21:31' prior: 33584354!offsetFromObjectOfInstanceVariable: arg1	| t |	t:=self objClass offsetFromClassOfInstanceVariable: arg1.	^t==0		ifTrue:[^self error:'']		ifFalse:[t].! !!Obj methodsFor: 'keyword management' stamp: '' prior: 36317213!returnValuesFrom: arg1 followingSchema: arg2	^ arg2		collect: [ :arg3 | self keywordValue: arg3 getFrom: arg1 ifAbsent: nil ]! !!Obj methodsFor: 'keyword management' stamp: '' prior: 36310018!generateKeywords: arg1	^ arg1 collect: [ :arg2 | (arg2 , ':') asSymbol ]! !!Obj methodsFor: 'keyword management' stamp: '' prior: 36308492!computeAndSetKeywords	self		objKeywords: (self generateKeywords: (self objIVs copyWithout: #class))! !!Obj methodsFor: 'keyword management' stamp: '' prior: 36310755!keywordValue: arg1 getFrom: arg2 ifAbsent: arg3	| tmp1 |	tmp1 := arg2 indexOf: arg1 ifAbsent: nil.	^ tmp1 isNil		ifTrue: [ arg3 ]		ifFalse: [ arg2 at: tmp1 + 1 ]! !!Obj methodsFor: 'instance initialization' stamp: '' prior: 36310325!initializeUsing: arg1	| tmp1 tmp2 |	tmp1 := self		returnValuesFrom: arg1		followingSchema: self objClass objKeywords.	tmp2 := tmp1 size.	1 to: tmp2 do: [ :tmp3 | self at: tmp3 + 1 put: (tmp1 at: tmp3) ]! !!Obj methodsFor: 'class structure primitive' stamp: '' prior: 36322617!objName: arg1	self at: self offsetForName put: arg1! !!Obj methodsFor: 'class structure primitive' stamp: '' prior: 36323583!objMethodDict	^ self at: self offsetForMethodDict! !!Obj methodsFor: 'class structure primitive' stamp: '' prior: 36321457!objKeywords	^ self at: self offsetForKeywords! !!Obj methodsFor: 'class structure primitive' stamp: '' prior: 36321691!objKeywords: arg1	self at: self offsetForKeywords put: arg1! !!Obj methodsFor: 'class structure primitive' stamp: '' prior: 36321166!objIVs: arg1	self at: self offsetForIVs put: arg1! !!Obj methodsFor: 'class structure primitive' stamp: '' prior: 36323366!objName	^ self at: self offsetForName! !!Obj methodsFor: 'class structure primitive' stamp: '' prior: 36322853!objSuperclassId: arg1	self at: self offsetForSuperclass put: arg1! !!Obj methodsFor: 'class structure primitive' stamp: '' prior: 36320632!objIVs	^ self at: self offsetForIVs! !!Obj methodsFor: 'class structure primitive' stamp: '' prior: 36322341!objMethodDict: arg1	self at: self offsetForMethodDict put: arg1! !!Obj methodsFor: 'class structure primitive' stamp: '' prior: 36323126!objSuperclassId	^ self at: self offsetForSuperclass! !!Obj methodsFor: 'class structure primitive' stamp: '' prior: 36314755!objSuperclass	^ Obj giveClassNamed: self objSuperclassId! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Obj class	instanceVariableNames: 'definedObjClasses'!!Obj class methodsFor: 'bootstrap objObject' stamp: '' prior: 36299639!createObjObject	| tmp1 |	tmp1 := self objObjectStructure.	tmp1		addUnaryMethod: #class withBody: 'objself objClass';		addUnaryMethod: #isClass withBody: 'false';		addUnaryMethod: #isMetaclass withBody: 'false';		addMethod: #error			args: 'arrayOfArguments'			withBody: 'Transcript show: ''error '', arrayOfArguments first.  ''error '', arrayOfArguments first';		addMethod: #getIV			args: 'iv'			withBody: 'objself valueOfInstanceVariable: iv';		addMethod: #setIV			args: 'iv val'			withBody: ' objself at: (objself offsetFromObjectOfInstanceVariable: iv) put: val';		addMethod: #initialize			args: 'initargs'			withBody: 'objself  initializeUsing: initargs'.	^ tmp1! !!Obj class methodsFor: 'bootstrap objObject' stamp: '' prior: 36305195!objObjectStructure	^ (Obj giveClassNamed: #ObjClass)		send: #new		withArguments: #(#(#name: #ObjObject #iv: #(#class)))! !!Obj class methodsFor: 'meta data' stamp: '' prior: 36298907!classInstanceVariables	^ #(#class #name #superclass #iv #keywords #methodDict)! !!Obj class methodsFor: 'global class repository management' stamp: '' prior: 36303114!giveClassNamed: arg1	^ self		giveClassNamed: arg1		ifAbsent: [ self error: 'The class ' , arg1 printString , ' is not defined' ]! !!Obj class methodsFor: 'global class repository management' stamp: '' prior: 36303431!giveClassNamed: arg1 ifAbsent: arg2	^ definedObjClasses at: arg1 ifAbsent: arg2! !!Obj class methodsFor: 'global class repository management' stamp: '' prior: 36300535!declareClass: arg1	| tmp1 |	tmp1 := arg1 objName.	tmp1 isNil		ifTrue: [ self error: 'The class does not have a name' ]		ifFalse: [ definedObjClasses at: tmp1 put: arg1 ]! !!Obj class methodsFor: 'initialize' stamp: '' prior: 36303603!initialize	definedObjClasses := IdentityDictionary new.	definedObjClasses		at: #ObjClass put: nil;		at: #ObjObject put: nil;		at: #ObjMessage put: nil! !!Obj class methodsFor: 'bootstrap objClass manually' stamp: '' prior: 36298705!bootstrap	self		initialize;		manuallyCreateObjClass;		createObjObject;		createObjClass! !!Obj class methodsFor: 'bootstrap objClass manually' stamp: '' prior: 36304335!manuallyCreateObjClass	| tmp1 |	tmp1 := self manualObjClassStructure.	Obj declareClass: tmp1.	self		defineManualInitializeMethodIn: tmp1;		defineNewMethodIn: tmp1;		defineAllocateMethodIn: tmp1.	^ tmp1! !!Obj class methodsFor: 'bootstrap objClass manually' stamp: '' prior: 36303911!manualObjClassStructure	| tmp1 |	tmp1 := Obj new: 6.	tmp1		objClassId: #ObjClass;		objName: #ObjClass;		objIVs: self classInstanceVariables;		objKeywords: #(#name: #superclass: #iv: #keywords: #methodDict:);		objSuperclassId: #ObjObject;		objMethodDict: (IdentityDictionary new: 3).	^ tmp1! !!Obj class methodsFor: 'bootstrap objClass manually' stamp: '' prior: 36300877!defineAllocateMethodIn: arg1	arg1 addUnaryMethod: #allocate withBody: 'objself allocateAnInstance'! !!Obj class methodsFor: 'bootstrap objClass manually' stamp: '' prior: 36302572!defineNewMethodIn: arg1	arg1		addMethod: #new		args: 'initArray'		withBody: '(objself send: #allocate withArguments: #()) send: #initialize withArguments: { initArray } '! !!Obj class methodsFor: 'bootstrap objClass manually' stamp: '' prior: 36301718!defineManualInitializeMethodIn: arg1	arg1		addMethod: #initialize		args: 'initArray'		withBody:			'| objsuperclass |			objself initializeUsing: initArray.	"Initialize a class as an object. In the bootstrapped system will be done via super"			objsuperclass := Obj giveClassNamed: objself objSuperclassId ifAbsent: [nil].			objsuperclass isNil				ifFalse: 					[objself						objIVs: (objself computeNewIVFrom: objsuperclass objIVs with: objself objIVs)]				ifTrue: 					[objself objIVs: (objself computeNewIVFrom: #(#class) with: objself objIVs)].			objself				objKeywords: (objself generateKeywords: (objself objIVs copyWithout: #class)).			objself objMethodDict: (IdentityDictionary new: 3).			Obj declareClass: objself.			objself'! !!Obj class methodsFor: 'bootstrap objClass' stamp: '' prior: 36299075!createObjClass	| tmp1 |	tmp1 := self objClassStructure.	self		defineAllocateMethodIn: tmp1;		defineNewMethodIn: tmp1;		defineInitializeMethodIn: tmp1.	tmp1		addUnaryMethod: #isMetaclass			withBody: 'objself objIVs includes: #superclass';		addUnaryMethod: #isClass			withBody: 'objself objClass send: #isMetaclass withArguments:#()'.	^ tmp1! !!Obj class methodsFor: 'bootstrap objClass' stamp: '' prior: 36301153!defineInitializeMethodIn: arg1	arg1		addMethod: #initialize		args: 'initArray'		withBody:			'objself super: #initialize withArguments: {initArray} from: superClassOfClassDefiningTheMethod.			objself objIVs: (objself							computeNewIVFrom: (Obj giveClassNamed: objself objSuperclassId) objIVs							with: objself objIVs).			objself computeAndSetKeywords.			objself objMethodDict: IdentityDictionary new.			Obj declareClass: objself.			objself'! !!Obj class methodsFor: 'bootstrap objClass' stamp: '' prior: 36304677!objClassStructure	^ (Obj giveClassNamed: #ObjClass)		send: #new		withArguments: #(#(#name: #ObjClass #iv: #(#name #superclass #iv #keywords #methodDict) #superclass: #ObjObject))! !!Obj class methodsFor: 'skeleton metadata' stamp: '' prior: 36305405!selectorsToSkeletonize	^ #(#objIVs #objIVs: #objKeywords #objKeywords: #objMethodDict #objMethodDict: #objName #objName: #objSuperclassId #objSuperclassId: #objClass #objClassId #objClassId: #allocateAnInstance #offsetFromClassOfInstanceVariable: #offsetFromObjectOfInstanceVariable: #valueOfInstanceVariable: #send:withArguments: #super:withArguments:from: #lookup: #bodyOfMethod:)! !!Obj class methodsFor: 'bootstrap objMessage' stamp: '' prior: 36297536!addMessagesForErrorHandling	| tmp1 |	tmp1 := self ObjMessage.	tmp1		addUnaryMethod: #receiver			withBody: 'objself valueOfInstanceVariable: #receiver';		addUnaryMethod: #receiver2			withBody: 'objself send: #getIV withArguments: #(#receiver)';		addUnaryMethod: #selector			withBody: 'objself send: #getIV withArguments: #(#selector)';		addUnaryMethod: #arguments			withBody: 'objself send: #getIV withArguments: #(#arguments)';		addMethod: #setReceiver			args: 'receiver'			withBody: ' objself send: #setIV withArguments: (Array with: #receiver with: receiver)';		addMethod: #setSelector			args: 'selector'			withBody: ' objself send: #setIV withArguments: (Array with: #selector with: selector)';		addMethod: #setArguments			args: 'arguments'			withBody: ' objself send: #setIV withArguments: (Array with: #arguments with: arguments)'.	^ tmp1! !!Obj class methodsFor: 'bootstrap objMessage' stamp: '' prior: 36304946!objClassStructureMessage	^ Obj ObjClass		send: #new		withArguments: #(#(#name: #ObjMessage #iv: #(#receiver #selector #arguments) #superclass: #ObjObject))! !!Obj class methodsFor: 'tricks' stamp: '' prior: 36302833!doesNotUnderstand: arg1	^ definedObjClasses at: arg1 selector! !TestCase subclass: #ObjTest	instanceVariableNames: 'objectClass aPoint coloredPointClass pointClass classClass aColoredPoint aIncrementalColoredPoint incrementalColoredPointClass'	classVariableNames: ''	poolDictionaries: ''	category: 'ObjVSkeleton'!!ObjTest methodsFor: 'utilities tests' stamp: '' prior: 36268347!testBlockBodyFromHeaderAndBody	self		assert:			(Obj new				stringOfBlockBodyFromHeader: 'val'				andBody:					'objself send: #setIV 										 withArguments: (Array with: #x with: val).')				=					'[ :superClassOfClassDefiningTheMethod |		[ :objself :val |					 objself send: #setIV 										 withArguments: (Array with: #x with: val).] ]';		assert:			(Obj new				stringOfBlockBodyFromHeader: ''				andBody: 'objself unarySend: #getx.')				=					'[ :superClassOfClassDefiningTheMethod |		[ :objself  |					 objself unarySend: #getx.] ]'! !!ObjTest methodsFor: 'utilities tests' stamp: '' prior: 36279875!testMethodWithHeaderAndBody	self		assert: ((pointClass methodWithHeader: '' andBody: 'objself ') value: 2) = 2;		assert:			((pointClass methodWithHeader: 'val' andBody: 'val ')				value: 2				value: 33) = 33;		assert:			((pointClass				methodWithHeader: ''				andBody: ' superClassOfClassDefiningTheMethod ') value: aPoint)				= objectClass;		assert:			((coloredPointClass				methodWithHeader: ''				andBody: ' superClassOfClassDefiningTheMethod ') value: aPoint)				= pointClass! !!ObjTest methodsFor: 'utilities tests' stamp: '' prior: 36268051!testBlockArgsFrom	self		assert: (Obj new blockArgsFrom: ' abc def ghi ') = ':abc :def :ghi';		assert: (Obj new blockArgsFrom: 'abc def ghi') = ':abc :def :ghi';		assert: (Obj new blockArgsFrom: '') = ''! !!ObjTest methodsFor: 'step2-tests-structure of classes' stamp: '' prior: 36282180!testPrimitiveStructureObjKeywords	self assert: pointClass objKeywords = #(#x: #y:)! !!ObjTest methodsFor: 'step2-tests-structure of classes' stamp: '' prior: 36282418!testPrimitiveStructureObjMethodDict	self assert: (pointClass objMethodDict = nil) not! !!ObjTest methodsFor: 'step2-tests-structure of classes' stamp: '' prior: 36282657!testPrimitiveStructureObjName	self assert: pointClass objName = #ObjPoint! !!ObjTest methodsFor: 'step2-tests-structure of classes' stamp: '' prior: 36281952!testPrimitiveStructureObjIVs	self assert: pointClass objIVs = #(#class #x #y)! !!ObjTest methodsFor: 'step2-tests-structure of classes' stamp: '' prior: 36282884!testPrimitiveStructureObjSuperclassId	self assert: pointClass objSuperclassId = #ObjObject! !!ObjTest methodsFor: 'setup' stamp: '' prior: 36259824!assembleClassClass	classClass := Obj new: 6.	classClass		at: classClass offsetForName put: #ObjClass;		at: classClass offsetForClass put: #ObjClass;		at: classClass offsetForIVs			put: #(#class #name #superclass #iv #keywords #methodDict);		at: classClass offsetForKeywords			put: #(#name: #superclass: #iv: #keywords: #methodDict:);		at: classClass offsetForSuperclass put: #ObjObject;		at: classClass offsetForMethodDict put: IdentityDictionary new.	Obj declareClass: classClass! !!ObjTest methodsFor: 'setup' stamp: '' prior: 36260441!assembleColoredInstance	aColoredPoint := Obj new: 4.	aColoredPoint		at: 1 put: #ObjColoredPoint;		at: 2 put: 10;		at: 3 put: 15;		at: 4 put: #blue! !!ObjTest methodsFor: 'setup' stamp: '' prior: 36262597!assembleIncrementalColoredPointClass	incrementalColoredPointClass := Obj new: 6.	incrementalColoredPointClass		at: pointClass offsetForName put: #ObjIncrementalColoredPoint;		at: pointClass offsetForClass put: #ObjClass;		at: pointClass offsetForIVs put: #(#color);		at: pointClass offsetForSuperclass put: #ObjPoint;		at: pointClass offsetForMethodDict put: IdentityDictionary new.	Obj declareClass: incrementalColoredPointClass.	(incrementalColoredPointClass		at: incrementalColoredPointClass offsetForMethodDict)		at: #print			put:			([ :arg1 | 			[ :arg2 | 			| tmp2 |			tmp2 := Transcript.			tmp2				show: 'I''am a colored point';				cr ] ] value: pointClass);		at: #foo			put:			([ :arg3 | 			[ :arg4 | 			(arg4 super: #foo withArguments: #() from: arg3)				+ (arg4 super: #foo withArguments: #() from: arg3) ] ]				value: pointClass);		at: #bar			put:			([ :arg5 | 			[ :arg6 | 			(arg6 super: #bar withArguments: #() from: arg5)				+ (arg6 super: #bar withArguments: #() from: arg5) ] ]				value: pointClass)! !!ObjTest methodsFor: 'setup' stamp: '' prior: 36260706!assembleColoredPointClass	coloredPointClass := Obj new: 6.	coloredPointClass		at: pointClass offsetForName put: #ObjColoredPoint;		at: pointClass offsetForClass put: #ObjClass;		at: pointClass offsetForIVs put: #(#class #x #y #color);		at: pointClass offsetForSuperclass put: #ObjPoint;		at: pointClass offsetForMethodDict put: IdentityDictionary new.	Obj declareClass: coloredPointClass.	(coloredPointClass at: coloredPointClass offsetForMethodDict)		at: #print			put:			([ :arg1 | 			[ :arg2 | 			| tmp2 |			tmp2 := Transcript.			tmp2				show: 'I''am a colored point';				cr ] ] value: pointClass);		at: #foo			put:			([ :arg3 | 			[ :arg4 | 			(arg4 super: #foo withArguments: #() from: arg3)				+ (arg4 super: #foo withArguments: #() from: arg3) ] ]				value: pointClass);		at: #bar			put:			([ :arg5 | 			[ :arg6 | 			(arg6 super: #bar withArguments: #() from: arg5)				+ (arg6 super: #bar withArguments: #() from: arg5) ] ]				value: pointClass)! !!ObjTest methodsFor: 'setup' stamp: '' prior: 36265945!assemblePointClass	| tmp1 |	tmp1 := Obj giveClassNamed: #ObjClass.	pointClass := Obj new: (tmp1 at: tmp1 offsetForIVs) size.	pointClass		at: pointClass offsetForName put: #ObjPoint;		at: pointClass offsetForClass put: #ObjClass;		at: pointClass offsetForIVs put: #(#class #x #y);		at: pointClass offsetForKeywords put: #(#x: #y:);		at: pointClass offsetForSuperclass put: #ObjObject;		at: pointClass offsetForMethodDict put: IdentityDictionary new.	Obj declareClass: pointClass.	(pointClass at: pointClass offsetForMethodDict)		at: #x			put:			([ :arg1 | [ :arg2 | arg2 valueOfInstanceVariable: #x ] ]				value: objectClass);		at: #print			put:			([ :arg3 | 			[ :arg4 | 			| tmp3 |			tmp3 := Transcript.			tmp3				show: 'I''am a Point';				cr ] ] value: objectClass);		at: #foo			put:			([ :arg5 | 			[ :arg6 | 			| tmp5 |			tmp5 := Transcript.			tmp5				show: 'ObjPoint>>foo';				cr.			5 ] ] value: objectClass)! !!ObjTest methodsFor: 'setup' stamp: '' prior: 36264284!assembleObjectClass	objectClass := Obj new: 6.	objectClass		at: objectClass offsetForName put: #ObjObject;		at: objectClass offsetForClass put: #ObjClass;		at: objectClass offsetForIVs put: #(#class);		at: objectClass offsetForKeywords put: #();		at: objectClass offsetForSuperclass put: nil;		at: objectClass offsetForMethodDict put: IdentityDictionary new.	Obj declareClass: objectClass.	(objectClass at: objectClass offsetForMethodDict)		at: #print			put:			([ :arg1 | 			[ :arg2 | 			| tmp2 |			tmp2 := Transcript.			tmp2				show: 'I''am an Object';				cr ] ] value: nil);		at: #error			put:			([ :arg3 | 			[ :arg4 :arg5 | 			| tmp4 |			tmp4 := Transcript.			tmp4				show: 'Error: selector ' , arg5 first printString , ' not understood';				cr.			Error signal ] ] value: nil);		at: #getIV			put:			([ :arg6 | [ :arg7 :arg8 | arg7 valueOfInstanceVariable: arg8 ] ]				value: nil);		at: #setIV			put:			([ :arg9 | [ :arg10 :arg11 :arg12 | arg10 at: (arg10 offsetFromObjectOfInstanceVariable: arg11) put: arg12 ] ]				value: nil);		at: #bar put: ([ :arg13 | [ :arg14 | 5 ] ] value: nil)! !!ObjTest methodsFor: 'setup' stamp: '' prior: 36267084!assemblePointInstance	aPoint := Obj new: 3.	aPoint		at: 1 put: #ObjPoint;		at: 2 put: 10;		at: 3 put: 15! !!ObjTest methodsFor: 'setup' stamp: '' prior: 36267278!setUp	Obj initialize.	self		assembleClassClass;		assemblePointClass;		assembleObjectClass;		assembleColoredPointClass;		assemblePointInstance;		assembleColoredInstance;		assembleIncrementalColoredInstance;		assembleIncrementalColoredPointClass! !!ObjTest methodsFor: 'setup' stamp: '' prior: 36262253!assembleIncrementalColoredInstance	aIncrementalColoredPoint := Obj new: 4.	aIncrementalColoredPoint		at: 1 put: #ObjIncrementalColoredPoint;		at: 2 put: 10;		at: 3 put: 15;		at: 4 put: #blue! !!ObjTest methodsFor: 'step3-tests-class access' stamp: '' prior: 36268988!testClassAccess	self assert: aPoint objClass = pointClass! !!ObjTest methodsFor: 'step4-tests-iv management' stamp: '' prior: 36270128!testIVOffset	self		assert: (pointClass offsetFromClassOfInstanceVariable: #x) = 2;		assert: (pointClass offsetFromClassOfInstanceVariable: #lulu) = 0! !!ObjTest methodsFor: 'step4-tests-iv management' stamp: '' prior: 36270382!testIVOffsetAndValue	self		assert: (aPoint offsetFromObjectOfInstanceVariable: #x) = 2;		assert: (aPoint valueOfInstanceVariable: #x) = 10! !!ObjTest methodsFor: 'step8-tests-instance variable inheritance' stamp: '' prior: 36271065!testInstanceVariableInheritance	self		assert:			(Obj new				computeNewIVFrom: #(#a #b #c #d) asOrderedCollection				with: #(#a #z #b #t) asOrderedCollection)				= #(#a #b #c #d #z #t) asOrderedCollection;		assert:			(Obj new				computeNewIVFrom: #() asOrderedCollection				with: #(#a #z #b #t) asOrderedCollection)				= #(#a #z #b #t) asOrderedCollection! !!ObjTest methodsFor: 'tests-MethodsManagement' stamp: '' prior: 36277605!testMethodManagmentNotUnderstandBadMethod	self assert: (pointClass doesUnderstand: #xx) not! !!ObjTest methodsFor: 'tests-MethodsManagement' stamp: '' prior: 36277849!testMethodManagmentUnderstandGoodMethod	self assert: (pointClass doesUnderstand: #x)! !!ObjTest methodsFor: 'tests-MethodsManagement' stamp: '' prior: 36276828!testMethodManagmentAddRemoveMethods	pointClass		addMethod: #xx		args: ''		withBody: 'objself valueOfInstanceVariable: #x '.	self		assert: ((pointClass bodyOfMethod: #xx) value: aPoint) = 10;		assert: (pointClass doesUnderstand: #xx).	pointClass removeMethod: #xx.	self		assert: (pointClass doesUnderstand: #xx) not;		assert: ((pointClass bodyOfMethod: #x) value: aPoint) = 10! !!ObjTest methodsFor: 'tests-MethodsManagement' stamp: '' prior: 36277366!testMethodManagmentBodyOfMethod	self assert: ((pointClass bodyOfMethod: #x) value: aPoint) = 10! !!ObjTest methodsFor: 'step7-tests-initialize' stamp: '' prior: 36270672!testInitialize	| tmp1 |	tmp1 := pointClass allocateAnInstance.	tmp1 initializeUsing: #(#y: 2 #z: 3 #t: 55 #x: 1).	self		assert: (tmp1 at: 1) equals: #ObjPoint;		assert: (tmp1 at: 2) equals: 1;		assert: (tmp1 at: 3) equals: 2! !!ObjTest methodsFor: 'tests-StaticInheritanceOfInstanceVariables' stamp: '' prior: 36272230!testInstanceVariableInheritanceFromAObject	aIncrementalColoredPoint objClass		objIVs:			(aIncrementalColoredPoint				computeNewIVFrom: aPoint objClass objIVs				with: aIncrementalColoredPoint objClass objIVs).	self		assert: (aPoint offsetFromObjectOfInstanceVariable: #x) = 2;		assert: (aIncrementalColoredPoint offsetFromObjectOfInstanceVariable: #x) = 2! !!ObjTest methodsFor: 'tests-StaticInheritanceOfInstanceVariables' stamp: '' prior: 36271677!testInstanceVariableInheritanceFromAClass	aIncrementalColoredPoint objClass		objIVs:			(aIncrementalColoredPoint				computeNewIVFrom: aPoint objClass objIVs				with: aIncrementalColoredPoint objClass objIVs).	self		assert: (pointClass offsetFromClassOfInstanceVariable: #x) = 2;		assert:			(incrementalColoredPointClass offsetFromClassOfInstanceVariable: #x)				= 2! !!ObjTest methodsFor: 'tests-StaticInheritanceOfInstanceVariables' stamp: '' prior: 36272769!testInstanceVariableInheritanceNotFind	self		should: [ aPoint offsetFromObjectOfInstanceVariable: #zork ]		raise: Error! !!ObjTest methodsFor: 'tests-StaticInheritanceOfInstanceVariables' stamp: '' prior: 36273061!testInstanceVariableInheritanceNumberOfInstanceVar	self		assert: pointClass numberOfIVs = 3;		assert: coloredPointClass numberOfIVs = 4! !!ObjTest methodsFor: 'step5-tests-allocate' stamp: '' prior: 36267667!testAllocate	| tmp1 |	tmp1 := pointClass allocateAnInstance.	self		assert: (tmp1 at: 1) = #ObjPoint;		assert: tmp1 size = 3;		assert: (tmp1 at: 2) isNil;		assert: (tmp1 at: 3) isNil;		assert: tmp1 objClass = pointClass! !!ObjTest methodsFor: 'tests' stamp: '' prior: 36273899!testMethodDefinition	self		assert: (pointClass doesUnderstand: #x);		assert: (pointClass doesUnderstand: #xx) not.	pointClass addMethod: #xx args: '' withBody: 'objself'.	self		assert: (pointClass doesUnderstand: #xx);		assert: ((pointClass bodyOfMethod: #xx) value: 22) = 22.	pointClass		addMethod: #getgetx		args: ''		withBody: 'objself valueOfInstanceVariable: #x'.	self		assert: (pointClass doesUnderstand: #getgetx);		assert: ((pointClass bodyOfMethod: #getgetx) value: aPoint) = 10! !!ObjTest methodsFor: 'tests' stamp: '' prior: 36278298!testMethodSelfSend	self		assert: (aPoint send: #x withArguments: #()) = 10;		assert: (aPoint send: #getIV withArguments: #(#x)) = 10.	aPoint send: #setIV withArguments: #(#y 22).	self assert: (aPoint send: #getIV withArguments: #(#y)) = 22! !!ObjTest methodsFor: 'tests' stamp: '' prior: 36279165!testMethodSuperCall	self		assert: (aPoint send: #foo withArguments: #()) = 5;		assert: (aColoredPoint send: #foo withArguments: #()) = 10! !!ObjTest methodsFor: 'tests' stamp: '' prior: 36279516!testMethodSuperCallOverBigHierarchy	self		assert: (aPoint send: #bar withArguments: #()) = 5;		assert: (aColoredPoint send: #bar withArguments: #()) = 10! !!ObjTest methodsFor: 'tests' stamp: '' prior: 36269505!testErrorRedefinition	self should: [ aPoint send: #zork withArguments: #() ] raise: Error.	(pointClass at: pointClass offsetForMethodDict)		at: #error		put: ([ :arg1 | [ :arg2 :arg3 | 33 ] ] value: objectClass).	self assert: (aPoint send: #zork withArguments: #()) = 33.	(pointClass at: pointClass offsetForMethodDict)		at: #error		put: ([ :arg4 | [ :arg5 :arg6 | 33 ] ] value: objectClass).	self assert: (aPoint send: #zork withArguments: #(44)) = 33! !!ObjTest methodsFor: 'tests' stamp: '' prior: 36278079!testMethodNotFoundRaiseError	self should: [ aPoint send: #zork withArguments: #() ] raise: Error! !!ObjTest methodsFor: 'tests' stamp: '' prior: 36280988!testPrimitiveStructure	self		assert: pointClass objClassId = #ObjClass;		assert: pointClass objName = #ObjPoint;		assert: pointClass objSuperclassId = #ObjObject;		assert: pointClass objIVs = #(#class #x #y);		assert: pointClass objKeywords = #(#x: #y:);		assert: (pointClass objMethodDict = nil) not! !!ObjTest methodsFor: 'tests' stamp: 'pm 11/3/2018 20:31' prior: 33581762!testMethodLookup	self assert: ((pointClass lookup: #x) isKindOf: BlockClosure)! !!ObjTest methodsFor: 'tests' stamp: '' prior: 36276220!testMethodManagement	self		assert: (pointClass doesUnderstand: #x);		assert: (pointClass doesUnderstand: #xx) not.	pointClass		addMethod: #xx		args: ''		withBody: 'objself valueOfInstanceVariable: #x '.	self		assert: ((pointClass bodyOfMethod: #xx) value: aPoint) = 10;		assert: (pointClass doesUnderstand: #xx).	pointClass removeMethod: #xx.	self		assert: (pointClass doesUnderstand: #xx) not;		assert: ((pointClass bodyOfMethod: #x) value: aPoint) = 10! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: '' prior: 36283155!testRaisesErrorSendWhenErrorInLookup	self		should: [ pointClass send: #zork withArguments: {aPoint} ]		raise: Error! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: '' prior: 36269200!testErrorRaisedSendWhenErrorInLookup	self		should: [ pointClass sendError: #zork withArgs: {aPoint} ]		raise: Error! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: '' prior: 36283490!testSendErrorRaisesErrorSendWhenErrorInLookup	self		should: [ pointClass sendError: #zork withArgs: {aPoint} ]		raise: Error! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: '' prior: 36278802!testMethodSelfSendUnarySend	self		assert: (aPoint send: #x withArguments: #()) = 10;		assert: (aColoredPoint send: #x withArguments: #()) = 10! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: '' prior: 36280750!testNilWhenErrorInLookup	self assert: (pointClass lookup: #zork) isNil! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: '' prior: 36275154!testMethodLookupFindSuperMethod	self assert: ((coloredPointClass lookup: #x) isKindOf: BlockClosure)! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: '' prior: 36275423!testMethodLookupStop	| tmp1 |	tmp1 := pointClass lookup: #zork.	self		assert: tmp1 isNil;		should: [ pointClass sendError: #error withArgs: {aPoint} ]			raise: Error.	tmp1 := pointClass lookup: #error.	self		assert: (tmp1 isKindOf: BlockClosure);		assert: ('*Error*' match: tmp1 printString);		should: [ (pointClass lookup: #zork) value: 'r' value: #e ]			raise: Error! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: '' prior: 36274890!testMethodLookupFindSimpleMethod	self assert: ((pointClass lookup: #x) isKindOf: BlockClosure)! !!ObjTest methodsFor: 'step6-tests-keywords' stamp: '' prior: 36273344!testKeywords	| tmp1 |	tmp1 := Obj new.	self		assert:			(tmp1 generateKeywords: #(#titi #toto #lulu))				= #(#titi: #toto: #lulu:);		assert: (tmp1 keywordValue: #x getFrom: #(#toto 33 #x 23) ifAbsent: 2) = 23;		assert: (tmp1 keywordValue: #x getFrom: #(#toto 23) ifAbsent: 2) = 2;		assert:			(tmp1				returnValuesFrom: #(#x 22 #y 35)				followingSchema: #(#y #yy #x #y)) = #(35 nil 22 35)! !!ObjTest methodsFor: 'step1-tests-structure of objects' stamp: '' prior: 36281705!testPrimitiveStructureObjClassIdForSimpleObject	self assert: aPoint objClassId = #ObjPoint! !!ObjTest methodsFor: 'step1-tests-structure of objects' stamp: '' prior: 36281474!testPrimitiveStructureObjClassId	self assert: pointClass objClassId = #ObjClass! !TestCase subclass: #RawObjTest	instanceVariableNames: 'objectClass aPoint coloredPointClass pointClass classClass aColoredPoint aIncrementalColoredPoint incrementalColoredPointClass'	classVariableNames: ''	poolDictionaries: ''	category: 'ObjVSkeleton'!!RawObjTest methodsFor: 'step1-tests-structure of objects' stamp: '' prior: 36296019!testPrimitiveStructureObjClassIdForSimpleObject	self assert: aPoint objClassId = #ObjPoint! !!RawObjTest methodsFor: 'step1-tests-structure of objects' stamp: '' prior: 36295770!testPrimitiveStructureObjClassId	self assert: pointClass objClassId = #ObjClass! !!RawObjTest methodsFor: 'step3-tests-class access' stamp: '' prior: 36295560!testClassAccess	self assert: aPoint objClass = pointClass! !!RawObjTest methodsFor: 'step2-tests-structure of classes' stamp: '' prior: 36296528!testPrimitiveStructureObjKeywords	self assert: pointClass objKeywords = #(#x: #y:)! !!RawObjTest methodsFor: 'step2-tests-structure of classes' stamp: '' prior: 36296783!testPrimitiveStructureObjMethodDict	self assert: (pointClass objMethodDict = nil) not! !!RawObjTest methodsFor: 'step2-tests-structure of classes' stamp: '' prior: 36297039!testPrimitiveStructureObjName	self assert: pointClass objName = #ObjPoint! !!RawObjTest methodsFor: 'step2-tests-structure of classes' stamp: '' prior: 36296283!testPrimitiveStructureObjIVs	self assert: pointClass objIVs = #(#class #x #y)! !!RawObjTest methodsFor: 'step2-tests-structure of classes' stamp: '' prior: 36297283!testPrimitiveStructureObjSuperclassId	self assert: pointClass objSuperclassId = #ObjObject! !!RawObjTest methodsFor: 'setup' stamp: '' prior: 36288250!assembleClassClass	classClass := Obj new: 6.	classClass		at: 2 put: #ObjClass;		at: 1 put: #ObjClass;		at: 4 put: #(#class #name #superclass #iv #keywords #methodDict);		at: 5 put: #(#name: #superclass: #iv: #keywords: #methodDict:);		at: 3 put: #ObjObject;		at: 6 put: IdentityDictionary new.	Obj declareClass: classClass! !!RawObjTest methodsFor: 'setup' stamp: '' prior: 36288710!assembleColoredInstance	aColoredPoint := Obj new: 4.	aColoredPoint		at: 1 put: #ObjColoredPoint;		at: 2 put: 10;		at: 3 put: 15;		at: 4 put: #blue! !!RawObjTest methodsFor: 'setup' stamp: '' prior: 36290742!assembleIncrementalColoredPointClass	incrementalColoredPointClass := Obj new: 6.	incrementalColoredPointClass		at: 2 put: #ObjIncrementalColoredPoint;		at: 1 put: #ObjClass;		at: 4 put: #(#color);		at: 3 put: #ObjPoint;		at: 6 put: IdentityDictionary new.	Obj declareClass: incrementalColoredPointClass.	(incrementalColoredPointClass		at: incrementalColoredPointClass offsetForMethodDict)		at: #print			put:			([ :arg1 | 			[ :arg2 | 			| tmp2 |			tmp2 := Transcript.			tmp2				show: 'I''am a colored point';				cr ] ] value: pointClass);		at: #foo			put:			([ :arg3 | 			[ :arg4 | 			(arg4 super: #foo withArguments: #() from: arg3)				+ (arg4 super: #foo withArguments: #() from: arg3) ] ]				value: pointClass);		at: #bar			put:			([ :arg5 | 			[ :arg6 | 			(arg6 super: #bar withArguments: #() from: arg5)				+ (arg6 super: #bar withArguments: #() from: arg5) ] ]				value: pointClass)! !!RawObjTest methodsFor: 'setup' stamp: '' prior: 36288978!assembleColoredPointClass	coloredPointClass := Obj new: 6.	coloredPointClass		at: 2 put: #ObjColoredPoint;		at: 1 put: #ObjClass;		at: 4 put: #(#class #x #y #color);		at: 3 put: #ObjPoint;		at: 6 put: IdentityDictionary new.	Obj declareClass: coloredPointClass.	(coloredPointClass at: coloredPointClass offsetForMethodDict)		at: #print			put:			([ :arg1 | 			[ :arg2 | 			| tmp2 |			tmp2 := Transcript.			tmp2				show: 'I''am a colored point';				cr ] ] value: pointClass);		at: #foo			put:			([ :arg3 | 			[ :arg4 | 			(arg4 super: #foo withArguments: #() from: arg3)				+ (arg4 super: #foo withArguments: #() from: arg3) ] ]				value: pointClass);		at: #bar			put:			([ :arg5 | 			[ :arg6 | 			(arg6 super: #bar withArguments: #() from: arg5)				+ (arg6 super: #bar withArguments: #() from: arg5) ] ]				value: pointClass)! !!RawObjTest methodsFor: 'setup' stamp: '' prior: 36293938!assemblePointClass	| tmp1 |	tmp1 := Obj giveClassNamed: #ObjClass.	pointClass := Obj new: (tmp1 at: tmp1 offsetForIVs) size.	pointClass		at: 2 put: #ObjPoint;		at: 1 put: #ObjClass;		at: 4 put: #(#class #x #y);		at: 5 put: #(#x: #y:);		at: 3 put: #ObjObject;		at: 6 put: IdentityDictionary new.	Obj declareClass: pointClass.	(pointClass at: pointClass offsetForMethodDict)		at: #x			put:			([ :arg1 | [ :arg2 | arg2 valueOfInstanceVariable: #x ] ]				value: objectClass);		at: #print			put:			([ :arg3 | 			[ :arg4 | 			| tmp3 |			tmp3 := Transcript.			tmp3				show: 'I''am a Point';				cr ] ] value: objectClass);		at: #foo			put:			([ :arg5 | 			[ :arg6 | 			| tmp5 |			tmp5 := Transcript.			tmp5				show: 'ObjPoint>>foo';				cr.			5 ] ] value: objectClass)! !!RawObjTest methodsFor: 'setup' stamp: '' prior: 36292303!assembleObjectClass	objectClass := Obj new: 6.	objectClass		at: 2 put: #ObjObject;		at: 1 put: #ObjClass;		at: objectClass offsetForIVs put: #(#class);		at: objectClass offsetForKeywords put: #();		at: objectClass offsetForSuperclass put: nil;		at: objectClass offsetForMethodDict put: IdentityDictionary new.	Obj declareClass: objectClass.	(objectClass at: objectClass offsetForMethodDict)		at: #print			put:			([ :arg1 | 			[ :arg2 | 			| tmp2 |			tmp2 := Transcript.			tmp2				show: 'I''am an Object';				cr ] ] value: nil);		at: #error			put:			([ :arg3 | 			[ :arg4 :arg5 | 			| tmp4 |			tmp4 := Transcript.			tmp4				show: 'Error: selector ' , arg5 printString , ' not understood';				cr.			Error signal ] ] value: nil);		at: #getIV			put:			([ :arg6 | [ :arg7 :arg8 | arg7 valueOfInstanceVariable: arg8 ] ]				value: nil);		at: #setIV			put:			([ :arg9 | [ :arg10 :arg11 :arg12 | arg10 at: (arg10 offsetFromObjectOfInstanceVariable: arg11) put: arg12 ] ]				value: nil);		at: #bar put: ([ :arg13 | [ :arg14 | 5 ] ] value: nil)! !!RawObjTest methodsFor: 'setup' stamp: '' prior: 36294966!assemblePointInstance	aPoint := Obj new: 3.	aPoint		at: 1 put: #ObjPoint;		at: 2 put: 10;		at: 3 put: 15! !!RawObjTest methodsFor: 'setup' stamp: '' prior: 36295164!setUp	Obj initialize.	self		assembleClassClass;		assemblePointClass;		assembleObjectClass;		assembleColoredPointClass;		assemblePointInstance;		assembleColoredInstance;		assembleIncrementalColoredInstance;		assembleIncrementalColoredPointClass! !!RawObjTest methodsFor: 'setup' stamp: '' prior: 36290395!assembleIncrementalColoredInstance	aIncrementalColoredPoint := Obj new: 4.	aIncrementalColoredPoint		at: 1 put: #ObjIncrementalColoredPoint;		at: 2 put: 10;		at: 3 put: 15;		at: 4 put: #blue! !Obj initialize!----End fileIn----!!Obj methodsFor: 'instance allocation' stamp: 'pm 11/4/2018 10:35' prior: 33597031!allocateAnInstance	| tmp1 size |	size := self numberOfIVs.	tmp1 := self class new: size.	tmp1 at: 1 put: self objName.	2 to: size do: [ :tmp3 | tmp1 at: tmp3 put: nil ].	^ tmp1! !!Obj methodsFor: 'iv management' stamp: 'pm 11/4/2018 10:37' prior: 33601416!valueOfInstanceVariable: arg1	| tmp1 |	tmp1 := self offsetFromObjectOfInstanceVariable: arg1.^ self at: tmp1! !!Obj methodsFor: 'iv management' stamp: 'pm 11/4/2018 10:37' prior: 33636830!valueOfInstanceVariable: arg1	| tmp1 |	tmp1 := self offsetFromObjectOfInstanceVariable: arg1.	^ self at: tmp1! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/4/2018 10:40' prior: 33598015!lookup: arg1	"question, do we have to search in metaclass aswell?	answer might be later in the tutorial"	| Method Super|	Method:=self bodyOfMethod:arg1.	Method isNil	ifFalse:[		^Method."we found a corresponding selector"		].	"else"	"we do the lookup in the superclass."		self super: #lookup withArguments: arg1 from: Method.	"	((self objSuperclassId) isNil) 	ifTrue:[		^nil.		].	Super:=self objSuperclass.	Super==self	ifTrue:[		^nil		].	^Super lookup:arg1.		"! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/4/2018 10:40' prior: 33637217!lookup: arg1	"question, do we have to search in metaclass aswell?	answer might be later in the tutorial"	| Method Super|	Method:=self bodyOfMethod:arg1.	Method isNil	ifFalse:[		^Method."we found a corresponding selector"		].	"else"	"we do the lookup in the superclass."		((self objSuperclassId) isNil) 	ifTrue:[		^nil.		].	Super:=self objSuperclass.	Super==self	ifTrue:[		^nil		].	^Super lookup:arg1.		! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/4/2018 10:42' prior: 33637787!lookup: arg1	"question, do we have to search in metaclass aswell?	answer might be later in the tutorial"	| method Super|	method:=self bodyOfMethod:arg1.	method isNil	ifFalse:[		^method."we found a corresponding selector"		].	"else"	"we do the lookup in the superclass."		((self objSuperclassId) isNil) 	ifTrue:[		^nil.		].	Super:=self objSuperclass.	Super==self	ifTrue:[		^nil		].	^Super lookup:arg1.		! !Array variableSubclass: #Obj	instanceVariableNames: ''	classVariableNames: ''	package: 'ObjVSkeleton'
!----QUIT----2018-11-05T19:36:11.328754+01:00 Pharo6.1-64.image priorSource: 30255!----QUIT----2018-11-05T19:36:40.406999+01:00 Pharo6.1-64.image priorSource: 84407!----QUIT----2018-11-08T20:11:01.698761+01:00 Pharo6.1-64.image priorSource: 84491!!Obj methodsFor: 'message passing' stamp: 'pm 11/23/2018 13:02' prior: 33599097!super: arg1 withArguments: arg2 from: arg3	^self  objSuperclass basicSend: arg1 withArguments: arg2 from: arg3.! !