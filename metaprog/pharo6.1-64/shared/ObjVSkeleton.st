TestCase variableSubclass: #ObjExampleTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ObjVSkeleton-AdvancedTests'!!ObjExampleTest methodsFor: 'test abstract'!testAbstractMetaclassExampleWithConcreteSubclass	self		shouldnt: [ Obj ObjPoint send: #new withArguments: #(#(#x: 24 #y: 6)) ]		raise: Error! !!ObjExampleTest methodsFor: 'test abstract'!testColoredPoint	| tmp1 tmp2 |	tmp1 := Obj ObjClass		send: #new		withArguments: #(#(#name: #ObjColoredPoint #iv: #(#color) #superclass: #ObjPoint)).	tmp2 := tmp1		send: #new		withArguments: #(#(#x: 24 #y: 6 #color: #blue)).	self assert: (tmp2 send: #getIV withArguments: #(#x)) = 24.	tmp2 send: #setIV withArguments: #(#x 25).	self		assert: (tmp2 send: #getIV withArguments: #(#x)) = 25;		assert: (tmp2 send: #getIV withArguments: #(#color)) = #blue.	tmp1		addUnaryMethod: #giveColor			withBody: 'objself send: #getIV withArguments: #(#color)';		addMethod: #setColor			args: 'col'			withBody: ' objself send: #setIV withArguments: (Array with: #color with: col)';		addUnaryMethod: #display			withBody:			'objself super: #display withArguments: #() from: superClassOfClassDefiningTheMethod.			Transcript cr;				show: '' with Color = ''.			Transcript show: (objself send: #giveColor withArguments: #()) printString;				cr'.	self		assert: (tmp2 send: #giveColor withArguments: #()) = #blue;		assert: (tmp2 send: #givex withArguments: #()) = 25.	tmp2 send: #display withArguments: #()! !!ObjExampleTest methodsFor: 'test abstract'!testAbstractMetaclassExample	self		should: [ Obj ObjAbstractClass send: #new withArguments: #(#(#x: 24 #y: 6)) ]		raise: Error! !!ObjExampleTest methodsFor: 'setup'!defineObjPoint	Obj ObjClass		send: #new		withArguments: #(#(#name: #ObjPoint #iv: #(#x #y) #superclass: #ObjAbstractPoint))! !!ObjExampleTest methodsFor: 'setup'!defineObjAbstractPoint	Obj ObjAbstractClass		send: #new		withArguments: #(#(#name: #ObjAbstractPoint #iv: #() #superclass: #ObjObject)).	Obj ObjAbstractPoint		addUnaryMethod: #givex			withBody: 'objself  valueOfInstanceVariable: #x ';		addUnaryMethod: #display			withBody:			'Transcript cr;				show: ''aPoint with x = ''.			Transcript show: (objself send: #givex withArguments: #()) printString;				cr'! !!ObjExampleTest methodsFor: 'setup'!setUp	Obj bootstrap.	self		abstractMetaclassDefinition;		defineObjAbstractPoint;		defineObjPoint! !!ObjExampleTest methodsFor: 'setup'!abstractMetaclassDefinition	(Obj giveClassNamed: #ObjClass)		send: #new		withArguments: #(#(#name: #ObjAbstractClass #iv: #() #superclass: #ObjClass)).	Obj ObjAbstractClass		addMethod: #new		args: 'initArray'		withBody: ' objself error: '' the class '' , objself objName asString , '' is abstract'''! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ObjExampleTest class	instanceVariableNames: ''!!ObjExampleTest class methodsFor: 'first user-defined metaclasses'!setMetaclassExample	| tmp1 |	self setMetaclassDefinition.	tmp1 := Obj ObjSet		send: #new		withArguments: #(#(#name: #ObjMemoPoint #iv: #() #superclass: #ObjPoint)).	tmp1		send: #new withArguments: #(#(#x: 24 #y: 6));		send: #new withArguments: #(#(#x: 15 #y: 10)).	^ tmp1 send: #instances withArguments: #()! !!ObjExampleTest class methodsFor: 'first user-defined metaclasses'!setMetaclassDefinition	| tmp1 |	tmp1 := Obj ObjClass		send: #new		withArguments: #(#(#name: #ObjSet #iv: #(#myInstances) #superclass: #ObjClass)).	tmp1		addMethod: #initialize			args: 'initArray'			withBody:			'			objself binarySuper: #initialize with: initArray from: superClassOfClassDefiningTheMethod.			objself send: #setIV				withArguments: (Array with: #myInstances with: OrderedCollection new).			objself';		addUnaryMethod: #instances			withBody: 'objself binarySend: #getIV with: #myInstances';		addMethod: #new			args: 'initArray'			withBody:			'| newInst others |			newInst := objself super: #new withArguments: (Array with: initArray) from: superClassOfClassDefiningTheMethod.			others := objself unarySend: #instances.			others := others add: newInst;						yourself.			objself send: #setIV withArguments: (Array with: #myInstances with: others).			newInst'! !TestCase subclass: #ObjTestBootstrap	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ObjVSkeleton-AdvancedTests'!!ObjTestBootstrap methodsFor: 'test ObjObject creation '!testCreateObjObjectMessage	| tmp1 |	Obj		initialize;		manuallyCreateObjClass;		createObjObject.	tmp1 := Obj giveClassNamed: #ObjObject.	self		assert:			(tmp1 send: #class withArguments: #())				= (Obj giveClassNamed: #ObjClass);		assert: (tmp1 send: #isClass withArguments: #()) not;		assert: (tmp1 send: #getIV withArguments: #(#class)) = #ObjClass! !!ObjTestBootstrap methodsFor: 'test ObjObject creation '!testCreateObjObjectInstanceMessage	| tmp1 tmp2 tmp3 |	Obj		initialize;		manuallyCreateObjClass;		createObjObject.	tmp2 := Obj giveClassNamed: #ObjClass.	tmp1 := tmp2		send: #new		withArguments: #(#(#name: #ObjPoint #superclass: #ObjObject #iv: #(#x #y))).	tmp3 := tmp1 send: #new withArguments: #(#()).	self		assert: tmp3 objClassId = #ObjPoint;		assert: (tmp3 send: #getIV withArguments: #(#x)) = nil.	tmp3 send: #setIV withArguments: #(#x 25).	self assert: (tmp3 send: #getIV withArguments: #(#x)) = 25! !!ObjTestBootstrap methodsFor: 'test ObjObject creation '!testCreateObjObjectStructure	| tmp1 |	Obj		initialize;		manuallyCreateObjClass;		createObjObject.	tmp1 := Obj giveClassNamed: #ObjObject.	self		assert: tmp1 objName = #ObjObject;		assert: tmp1 objClassId = #ObjClass;		assert: tmp1 objSuperclassId isNil;		assert: tmp1 objIVs asArray = #(#class);		assert: tmp1 objKeywords asArray = #()! !!ObjTestBootstrap methodsFor: 'test ObjClass manual creation '!testManuallyCreateObjClassAllocate	| tmp1 tmp2 |	Obj		initialize;		manuallyCreateObjClass.	tmp1 := Obj giveClassNamed: #ObjClass.	tmp2 := tmp1 send: #allocate withArguments: #().	self		assert: tmp2 objClassId = #ObjClass;		assert: tmp2 objSuperclassId isNil;		assert: tmp2 objIVs isNil;		assert: tmp2 objKeywords isNil;		assert: tmp2 objMethodDict isNil;		assert: tmp2 objName isNil! !!ObjTestBootstrap methodsFor: 'test ObjClass manual creation '!testManuallyCreateObjClassStructure	| tmp1 |	Obj		initialize;		manuallyCreateObjClass.	tmp1 := Obj giveClassNamed: #ObjClass.	self		assert: tmp1 objName = #ObjClass;		assert: tmp1 objClassId = #ObjClass;		assert: tmp1 objClass == tmp1;		assert: tmp1 objSuperclassId = #ObjObject;		assert: tmp1 objIVs = #(#class #name #superclass #iv #keywords #methodDict);		assert: tmp1 objKeywords = #(#name: #superclass: #iv: #keywords: #methodDict:)! !!ObjTestBootstrap methodsFor: 'test ObjClass creation'!testCreateObjClassStructure	| tmp1 |	Obj bootstrap.	tmp1 := Obj giveClassNamed: #ObjClass.	self		assert: tmp1 objName = #ObjClass;		assert: tmp1 objClassId = #ObjClass;		assert: tmp1 objSuperclassId = #ObjObject;		assert:			tmp1 objIVs asArray				= #(#class #name #superclass #iv #keywords #methodDict);		assert:			tmp1 objKeywords asArray				= #(#name: #superclass: #iv: #keywords: #methodDict:)! !!ObjTestBootstrap methodsFor: 'test ObjClass creation'!testCreateObjClassMessage	| tmp1 |	Obj bootstrap.	tmp1 := Obj giveClassNamed: #ObjClass.	self		assert:			(tmp1 send: #class withArguments: #())				= (Obj giveClassNamed: #ObjClass);		assert: (tmp1 send: #isClass withArguments: #());		assert: (tmp1 send: #isMetaclass withArguments: #())! !EyeCollectionInspector variableSubclass: #ObjClassInspector	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ObjVSkeleton-Inspector'!!ObjClassInspector methodsFor: 'list'!addVariableFields: arg1	| tmp1 |	tmp1 := Obj classInstanceVariables.	tmp1		do: [ :arg2 | 			| tmp3 |			tmp3 := StrictlyOrderedEyeElement new.			tmp3				orderedStructure: tmp1;				host: self object;				index: arg2.			arg1 add: tmp3 yourself ]! !BasicIndexedEyeElement variableSubclass: #StrictlyOrderedEyeElement	instanceVariableNames: 'orderedStructure'	classVariableNames: ''	poolDictionaries: ''	category: 'ObjVSkeleton-Inspector'!!StrictlyOrderedEyeElement methodsFor: 'accessing'!orderedStructure	^ orderedStructure! !!StrictlyOrderedEyeElement methodsFor: 'accessing'!orderedStructure: arg1	orderedStructure := arg1! !!StrictlyOrderedEyeElement methodsFor: 'accessing'!value	^ self host basicAt: (self orderedStructure indexOf: index)! !TestCase subclass: #ObjMessageTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ObjVSkeleton-Experimental'!!ObjMessageTest methodsFor: 'setup'!setUp	Obj		bootstrap;		objClassStructureMessage! !!ObjMessageTest methodsFor: 'tests'!testMessageClassStructureDeclared	Obj objClassStructureMessage.	self		assert: Obj ObjMessage objName = #ObjMessage;		assert: Obj ObjMessage objClass objName = #ObjClass;		assert:			Obj ObjMessage objIVs asArray				= #(#class #receiver #selector #arguments);		assert: Obj ObjMessage objSuperclass = Obj ObjObject! !!ObjMessageTest methodsFor: 'tests'!testMessageClassMethodsDefined	| tmp1 |	Obj addMessagesForErrorHandling.	self deny: Obj ObjMessage objMethodDict size isZero! !!ObjMessageTest methodsFor: 'tests'!testMessageClassMethods	| tmp1 |	Obj addMessagesForErrorHandling.	tmp1 := Obj ObjMessage		send: #new		withArguments: #(#(#receiver: 24 #selector: #factorial)).	self		assert: (tmp1 send: #receiver2 withArguments: #()) equals: 24;		assert: (tmp1 send: #receiver withArguments: #()) equals: 24;		assert: (tmp1 send: #selector withArguments: #())			equals: #factorial.	tmp1 := Obj ObjMessage		send: #new		withArguments: #(#(#receiver: 24 #selector: #+ #arguments: #(25))).	self assert: (tmp1 send: #arguments withArguments: #()) equals: #(25)! !!ObjMessageTest methodsFor: 'tests'!testUsingPrimitivesMessageClassMethods	| tmp1 |	tmp1 := Obj ObjMessage		send: #new		withArguments: #(#(#receiver: 24 #selector: #factorial)).	self		assert: (tmp1 at: 1) equals: #ObjMessage;		assert: (tmp1 at: 2) equals: 24;		assert: (tmp1 at: 3) equals: #factorial.	tmp1 := Obj ObjMessage		send: #new		withArguments: #(#(#receiver: 24 #selector: #+ #arguments: #(25))).	self assert: (tmp1 at: 4) equals: #(25)! !Array variableSubclass: #Obj	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ObjVSkeleton'!!Obj methodsFor: 'class structure offset'!offsetForIVs	^ 4! !!Obj methodsFor: 'class structure offset'!offsetForMethodDict	^ 6! !!Obj methodsFor: 'class structure offset'!offsetForName	^ 2! !!Obj methodsFor: 'class structure offset'!offsetForSuperclass	^ 3! !!Obj methodsFor: 'class structure offset'!offsetForKeywords	^ 5! !!Obj methodsFor: 'printing'!printOn: arg1	arg1 nextPutAll: 'an Obj object: '.	super printOn: arg1! !!Obj methodsFor: 'object structure primitive'!objClassId	^ self at: self offsetForClass! !!Obj methodsFor: 'object structure primitive'!objClassId: arg1	self at: self offsetForClass put: arg1! !!Obj methodsFor: 'object structure primitive'!objClass	^ self class giveClassNamed: self objClassId! !!Obj methodsFor: 'instance allocation'!allocateAnInstance	| tmp1 tmp2 |	tmp1 := self class new: self numberOfIVs.	tmp1 at: 1 put: self objName.	tmp2 := self numberOfIVs.	2 to: tmp2 do: [ :tmp3 | tmp1 at: tmp3 put: nil ].	^ tmp1! !!Obj methodsFor: 'debugging'!classDebug	ObjClassInspector basicInspect: self! !!Obj methodsFor: 'iv inheritance'!computeNewIVFromClass: arg1 with: arg2	| tmp1 |	^ arg1 isNil		ifTrue: [ arg2 ]		ifFalse: [ tmp1 := arg1 objIVs asOrderedCollection copy.			arg2				do: [ :arg3 | 					(tmp1 includes: arg3)						ifFalse: [ tmp1 add: arg3 ] ].			tmp1 ]! !!Obj methodsFor: 'iv inheritance'!computeNewIVFrom: arg1 with: arg2	| tmp1 |	^ arg1 isNil		ifTrue: [ arg2 ]		ifFalse: [ tmp1 := arg1 asOrderedCollection copy.			arg2				do: [ :arg3 | 					(tmp1 includes: arg3)						ifFalse: [ tmp1 add: arg3 ] ].			tmp1 ]! !!Obj methodsFor: 'method lookup' stamp: 'pm 11/3/2018 20:27'!lookup: arg1	"question, do we have to search in metaclass aswell?	answer might be later in the tutorial"	| Method Super|	Method:=self bodyOfMethod:arg1.	Method isNil	ifFalse:[		^Method."we found a corresponding selector"		].	"else"	"we do the lookup in the superclass."	((self objSuperclassId) isNil) "if we don't have a super class, we fail."	ifTrue:[		^nil.		].	Super:=self objSuperclass.	Super==self	ifTrue:[		^nil		].	^Super lookup:arg1.		! !!Obj methodsFor: 'object structure offset'!offsetForClass	^ 1! !!Obj methodsFor: 'message passing'!basicSend: arg1 withArguments: arg2 from: arg3	| tmp1 |	tmp1 := arg3 lookup: arg1.	^ tmp1		ifNil: [ self sendError: arg1 withArgs: arg2 ]		ifNotNil: [ tmp1 valueWithArguments: (Array with: self) , arg2 ]! !!Obj methodsFor: 'message passing'!sendError: arg1 withArgs: arg2	^ self send: #error withArguments: {(arg2 copyWithFirst: arg1)}! !!Obj methodsFor: 'message passing' stamp: 'pm 11/3/2018 20:53'!super: arg1 withArguments: arg2 from: arg3	^(self objClass) objSuperclass basicSend: arg1 withArguments: arg2 from: arg3.! !!Obj methodsFor: 'message passing' stamp: 'pm 11/3/2018 20:26'!send: arg1 withArguments: arg2	"or is it?"	^self basicSend: arg1 withArguments: arg2 from: (self objClass).! !!Obj methodsFor: 'method management'!removeMethod: arg1	self objMethodDict removeKey: arg1 ifAbsent: [  ]! !!Obj methodsFor: 'method management'!methodWithHeader: arg1 andBody: arg2	| tmp1 tmp2 tmp3 |	tmp2 := self stringOfBlockBodyFromHeader: arg1 andBody: arg2.	tmp1 := Compiler evaluate: tmp2.	tmp3 := tmp1		value: (Obj giveClassNamed: self objSuperclassId ifAbsent: [ 666 ]).	^ tmp3! !!Obj methodsFor: 'method management'!addUnaryMethod: arg1 withBody: arg2	self addMethod: arg1 args: '' withBody: arg2! !!Obj methodsFor: 'method management' stamp: 'pm 11/3/2018 20:30'!bodyOfMethod: arg1	^self objMethodDict at: arg1 ifAbsent: [ nil ].! !!Obj methodsFor: 'method management'!blockArgsFrom: arg1	| tmp1 tmp3 |	tmp1 := arg1 findTokens: Character space.	tmp1 := tmp1 copyWithout: ''.	tmp3 := ''.	tmp1		do: [ :arg2 | tmp3 := tmp3 , ':' , arg2 ]		separatedBy: [ tmp3 := tmp3 , ' ' ].	^ tmp3! !!Obj methodsFor: 'method management'!stringOfBlockBodyFromHeader: arg1 andBody: arg2	^ '[ :superClassOfClassDefiningTheMethod |		[ :objself ' , (self blockArgsFrom: arg1)		,			' |					 ' , arg2 , '] ]'! !!Obj methodsFor: 'method management'!addMethod: arg1 args: arg2 withBody: arg3	self objMethodDict		at: arg1		put: (self methodWithHeader: arg2 andBody: arg3)! !!Obj methodsFor: 'method management'!doesUnderstand: arg1	^ self objMethodDict keys includes: arg1! !!Obj methodsFor: 'iv management'!offsetFromClassOfInstanceVariable: arg1	| tmp2 |	tmp2 := self numberOfIVs.	1 to: tmp2 do: [ :tmp1 | 		arg1 = (self objIVs at: tmp1)			ifTrue: [ ^ tmp1 ] ].	^ 0! !!Obj methodsFor: 'iv management'!numberOfIVs	^ self objIVs size! !!Obj methodsFor: 'iv management' stamp: 'pm 11/3/2018 21:00'!valueOfInstanceVariable: arg1	| tmp1 |	tmp1 := self offsetFromObjectOfInstanceVariable: arg1.	tmp1 ~= 0		ifTrue: [ ^ self at: tmp1 ].! !!Obj methodsFor: 'iv management' stamp: 'pm 11/3/2018 21:31'!offsetFromObjectOfInstanceVariable: arg1	| t |	t:=self objClass offsetFromClassOfInstanceVariable: arg1.	^t==0		ifTrue:[^self error:'']		ifFalse:[t].! !!Obj methodsFor: 'keyword management'!returnValuesFrom: arg1 followingSchema: arg2	^ arg2		collect: [ :arg3 | self keywordValue: arg3 getFrom: arg1 ifAbsent: nil ]! !!Obj methodsFor: 'keyword management'!generateKeywords: arg1	^ arg1 collect: [ :arg2 | (arg2 , ':') asSymbol ]! !!Obj methodsFor: 'keyword management'!computeAndSetKeywords	self		objKeywords: (self generateKeywords: (self objIVs copyWithout: #class))! !!Obj methodsFor: 'keyword management'!keywordValue: arg1 getFrom: arg2 ifAbsent: arg3	| tmp1 |	tmp1 := arg2 indexOf: arg1 ifAbsent: nil.	^ tmp1 isNil		ifTrue: [ arg3 ]		ifFalse: [ arg2 at: tmp1 + 1 ]! !!Obj methodsFor: 'instance initialization'!initializeUsing: arg1	| tmp1 tmp2 |	tmp1 := self		returnValuesFrom: arg1		followingSchema: self objClass objKeywords.	tmp2 := tmp1 size.	1 to: tmp2 do: [ :tmp3 | self at: tmp3 + 1 put: (tmp1 at: tmp3) ]! !!Obj methodsFor: 'class structure primitive'!objName: arg1	self at: self offsetForName put: arg1! !!Obj methodsFor: 'class structure primitive'!objMethodDict	^ self at: self offsetForMethodDict! !!Obj methodsFor: 'class structure primitive'!objKeywords	^ self at: self offsetForKeywords! !!Obj methodsFor: 'class structure primitive'!objKeywords: arg1	self at: self offsetForKeywords put: arg1! !!Obj methodsFor: 'class structure primitive'!objIVs: arg1	self at: self offsetForIVs put: arg1! !!Obj methodsFor: 'class structure primitive'!objName	^ self at: self offsetForName! !!Obj methodsFor: 'class structure primitive'!objSuperclassId: arg1	self at: self offsetForSuperclass put: arg1! !!Obj methodsFor: 'class structure primitive'!objIVs	^ self at: self offsetForIVs! !!Obj methodsFor: 'class structure primitive'!objMethodDict: arg1	self at: self offsetForMethodDict put: arg1! !!Obj methodsFor: 'class structure primitive'!objSuperclassId	^ self at: self offsetForSuperclass! !!Obj methodsFor: 'class structure primitive'!objSuperclass	^ Obj giveClassNamed: self objSuperclassId! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Obj class	instanceVariableNames: 'definedObjClasses'!!Obj class methodsFor: 'bootstrap objObject'!createObjObject	| tmp1 |	tmp1 := self objObjectStructure.	tmp1		addUnaryMethod: #class withBody: 'objself objClass';		addUnaryMethod: #isClass withBody: 'false';		addUnaryMethod: #isMetaclass withBody: 'false';		addMethod: #error			args: 'arrayOfArguments'			withBody: 'Transcript show: ''error '', arrayOfArguments first.  ''error '', arrayOfArguments first';		addMethod: #getIV			args: 'iv'			withBody: 'objself valueOfInstanceVariable: iv';		addMethod: #setIV			args: 'iv val'			withBody: ' objself at: (objself offsetFromObjectOfInstanceVariable: iv) put: val';		addMethod: #initialize			args: 'initargs'			withBody: 'objself  initializeUsing: initargs'.	^ tmp1! !!Obj class methodsFor: 'bootstrap objObject'!objObjectStructure	^ (Obj giveClassNamed: #ObjClass)		send: #new		withArguments: #(#(#name: #ObjObject #iv: #(#class)))! !!Obj class methodsFor: 'meta data'!classInstanceVariables	^ #(#class #name #superclass #iv #keywords #methodDict)! !!Obj class methodsFor: 'global class repository management'!giveClassNamed: arg1	^ self		giveClassNamed: arg1		ifAbsent: [ self error: 'The class ' , arg1 printString , ' is not defined' ]! !!Obj class methodsFor: 'global class repository management'!giveClassNamed: arg1 ifAbsent: arg2	^ definedObjClasses at: arg1 ifAbsent: arg2! !!Obj class methodsFor: 'global class repository management'!declareClass: arg1	| tmp1 |	tmp1 := arg1 objName.	tmp1 isNil		ifTrue: [ self error: 'The class does not have a name' ]		ifFalse: [ definedObjClasses at: tmp1 put: arg1 ]! !!Obj class methodsFor: 'initialize'!initialize	definedObjClasses := IdentityDictionary new.	definedObjClasses		at: #ObjClass put: nil;		at: #ObjObject put: nil;		at: #ObjMessage put: nil! !!Obj class methodsFor: 'bootstrap objClass manually'!bootstrap	self		initialize;		manuallyCreateObjClass;		createObjObject;		createObjClass! !!Obj class methodsFor: 'bootstrap objClass manually'!manuallyCreateObjClass	| tmp1 |	tmp1 := self manualObjClassStructure.	Obj declareClass: tmp1.	self		defineManualInitializeMethodIn: tmp1;		defineNewMethodIn: tmp1;		defineAllocateMethodIn: tmp1.	^ tmp1! !!Obj class methodsFor: 'bootstrap objClass manually'!manualObjClassStructure	| tmp1 |	tmp1 := Obj new: 6.	tmp1		objClassId: #ObjClass;		objName: #ObjClass;		objIVs: self classInstanceVariables;		objKeywords: #(#name: #superclass: #iv: #keywords: #methodDict:);		objSuperclassId: #ObjObject;		objMethodDict: (IdentityDictionary new: 3).	^ tmp1! !!Obj class methodsFor: 'bootstrap objClass manually'!defineAllocateMethodIn: arg1	arg1 addUnaryMethod: #allocate withBody: 'objself allocateAnInstance'! !!Obj class methodsFor: 'bootstrap objClass manually'!defineNewMethodIn: arg1	arg1		addMethod: #new		args: 'initArray'		withBody: '(objself send: #allocate withArguments: #()) send: #initialize withArguments: { initArray } '! !!Obj class methodsFor: 'bootstrap objClass manually'!defineManualInitializeMethodIn: arg1	arg1		addMethod: #initialize		args: 'initArray'		withBody:			'| objsuperclass |			objself initializeUsing: initArray.	"Initialize a class as an object. In the bootstrapped system will be done via super"			objsuperclass := Obj giveClassNamed: objself objSuperclassId ifAbsent: [nil].			objsuperclass isNil				ifFalse: 					[objself						objIVs: (objself computeNewIVFrom: objsuperclass objIVs with: objself objIVs)]				ifTrue: 					[objself objIVs: (objself computeNewIVFrom: #(#class) with: objself objIVs)].			objself				objKeywords: (objself generateKeywords: (objself objIVs copyWithout: #class)).			objself objMethodDict: (IdentityDictionary new: 3).			Obj declareClass: objself.			objself'! !!Obj class methodsFor: 'bootstrap objClass'!createObjClass	| tmp1 |	tmp1 := self objClassStructure.	self		defineAllocateMethodIn: tmp1;		defineNewMethodIn: tmp1;		defineInitializeMethodIn: tmp1.	tmp1		addUnaryMethod: #isMetaclass			withBody: 'objself objIVs includes: #superclass';		addUnaryMethod: #isClass			withBody: 'objself objClass send: #isMetaclass withArguments:#()'.	^ tmp1! !!Obj class methodsFor: 'bootstrap objClass'!defineInitializeMethodIn: arg1	arg1		addMethod: #initialize		args: 'initArray'		withBody:			'objself super: #initialize withArguments: {initArray} from: superClassOfClassDefiningTheMethod.			objself objIVs: (objself							computeNewIVFrom: (Obj giveClassNamed: objself objSuperclassId) objIVs							with: objself objIVs).			objself computeAndSetKeywords.			objself objMethodDict: IdentityDictionary new.			Obj declareClass: objself.			objself'! !!Obj class methodsFor: 'bootstrap objClass'!objClassStructure	^ (Obj giveClassNamed: #ObjClass)		send: #new		withArguments: #(#(#name: #ObjClass #iv: #(#name #superclass #iv #keywords #methodDict) #superclass: #ObjObject))! !!Obj class methodsFor: 'skeleton metadata'!selectorsToSkeletonize	^ #(#objIVs #objIVs: #objKeywords #objKeywords: #objMethodDict #objMethodDict: #objName #objName: #objSuperclassId #objSuperclassId: #objClass #objClassId #objClassId: #allocateAnInstance #offsetFromClassOfInstanceVariable: #offsetFromObjectOfInstanceVariable: #valueOfInstanceVariable: #send:withArguments: #super:withArguments:from: #lookup: #bodyOfMethod:)! !!Obj class methodsFor: 'bootstrap objMessage'!addMessagesForErrorHandling	| tmp1 |	tmp1 := self ObjMessage.	tmp1		addUnaryMethod: #receiver			withBody: 'objself valueOfInstanceVariable: #receiver';		addUnaryMethod: #receiver2			withBody: 'objself send: #getIV withArguments: #(#receiver)';		addUnaryMethod: #selector			withBody: 'objself send: #getIV withArguments: #(#selector)';		addUnaryMethod: #arguments			withBody: 'objself send: #getIV withArguments: #(#arguments)';		addMethod: #setReceiver			args: 'receiver'			withBody: ' objself send: #setIV withArguments: (Array with: #receiver with: receiver)';		addMethod: #setSelector			args: 'selector'			withBody: ' objself send: #setIV withArguments: (Array with: #selector with: selector)';		addMethod: #setArguments			args: 'arguments'			withBody: ' objself send: #setIV withArguments: (Array with: #arguments with: arguments)'.	^ tmp1! !!Obj class methodsFor: 'bootstrap objMessage'!objClassStructureMessage	^ Obj ObjClass		send: #new		withArguments: #(#(#name: #ObjMessage #iv: #(#receiver #selector #arguments) #superclass: #ObjObject))! !!Obj class methodsFor: 'tricks'!doesNotUnderstand: arg1	^ definedObjClasses at: arg1 selector! !TestCase subclass: #ObjTest	instanceVariableNames: 'objectClass aPoint coloredPointClass pointClass classClass aColoredPoint aIncrementalColoredPoint incrementalColoredPointClass'	classVariableNames: ''	poolDictionaries: ''	category: 'ObjVSkeleton'!!ObjTest methodsFor: 'utilities tests'!testBlockBodyFromHeaderAndBody	self		assert:			(Obj new				stringOfBlockBodyFromHeader: 'val'				andBody:					'objself send: #setIV 										 withArguments: (Array with: #x with: val).')				=					'[ :superClassOfClassDefiningTheMethod |		[ :objself :val |					 objself send: #setIV 										 withArguments: (Array with: #x with: val).] ]';		assert:			(Obj new				stringOfBlockBodyFromHeader: ''				andBody: 'objself unarySend: #getx.')				=					'[ :superClassOfClassDefiningTheMethod |		[ :objself  |					 objself unarySend: #getx.] ]'! !!ObjTest methodsFor: 'utilities tests'!testMethodWithHeaderAndBody	self		assert: ((pointClass methodWithHeader: '' andBody: 'objself ') value: 2) = 2;		assert:			((pointClass methodWithHeader: 'val' andBody: 'val ')				value: 2				value: 33) = 33;		assert:			((pointClass				methodWithHeader: ''				andBody: ' superClassOfClassDefiningTheMethod ') value: aPoint)				= objectClass;		assert:			((coloredPointClass				methodWithHeader: ''				andBody: ' superClassOfClassDefiningTheMethod ') value: aPoint)				= pointClass! !!ObjTest methodsFor: 'utilities tests'!testBlockArgsFrom	self		assert: (Obj new blockArgsFrom: ' abc def ghi ') = ':abc :def :ghi';		assert: (Obj new blockArgsFrom: 'abc def ghi') = ':abc :def :ghi';		assert: (Obj new blockArgsFrom: '') = ''! !!ObjTest methodsFor: 'step2-tests-structure of classes'!testPrimitiveStructureObjKeywords	self assert: pointClass objKeywords = #(#x: #y:)! !!ObjTest methodsFor: 'step2-tests-structure of classes'!testPrimitiveStructureObjMethodDict	self assert: (pointClass objMethodDict = nil) not! !!ObjTest methodsFor: 'step2-tests-structure of classes'!testPrimitiveStructureObjName	self assert: pointClass objName = #ObjPoint! !!ObjTest methodsFor: 'step2-tests-structure of classes'!testPrimitiveStructureObjIVs	self assert: pointClass objIVs = #(#class #x #y)! !!ObjTest methodsFor: 'step2-tests-structure of classes'!testPrimitiveStructureObjSuperclassId	self assert: pointClass objSuperclassId = #ObjObject! !!ObjTest methodsFor: 'setup'!assembleClassClass	classClass := Obj new: 6.	classClass		at: classClass offsetForName put: #ObjClass;		at: classClass offsetForClass put: #ObjClass;		at: classClass offsetForIVs			put: #(#class #name #superclass #iv #keywords #methodDict);		at: classClass offsetForKeywords			put: #(#name: #superclass: #iv: #keywords: #methodDict:);		at: classClass offsetForSuperclass put: #ObjObject;		at: classClass offsetForMethodDict put: IdentityDictionary new.	Obj declareClass: classClass! !!ObjTest methodsFor: 'setup'!assembleColoredInstance	aColoredPoint := Obj new: 4.	aColoredPoint		at: 1 put: #ObjColoredPoint;		at: 2 put: 10;		at: 3 put: 15;		at: 4 put: #blue! !!ObjTest methodsFor: 'setup'!assembleIncrementalColoredPointClass	incrementalColoredPointClass := Obj new: 6.	incrementalColoredPointClass		at: pointClass offsetForName put: #ObjIncrementalColoredPoint;		at: pointClass offsetForClass put: #ObjClass;		at: pointClass offsetForIVs put: #(#color);		at: pointClass offsetForSuperclass put: #ObjPoint;		at: pointClass offsetForMethodDict put: IdentityDictionary new.	Obj declareClass: incrementalColoredPointClass.	(incrementalColoredPointClass		at: incrementalColoredPointClass offsetForMethodDict)		at: #print			put:			([ :arg1 | 			[ :arg2 | 			| tmp2 |			tmp2 := Transcript.			tmp2				show: 'I''am a colored point';				cr ] ] value: pointClass);		at: #foo			put:			([ :arg3 | 			[ :arg4 | 			(arg4 super: #foo withArguments: #() from: arg3)				+ (arg4 super: #foo withArguments: #() from: arg3) ] ]				value: pointClass);		at: #bar			put:			([ :arg5 | 			[ :arg6 | 			(arg6 super: #bar withArguments: #() from: arg5)				+ (arg6 super: #bar withArguments: #() from: arg5) ] ]				value: pointClass)! !!ObjTest methodsFor: 'setup'!assembleColoredPointClass	coloredPointClass := Obj new: 6.	coloredPointClass		at: pointClass offsetForName put: #ObjColoredPoint;		at: pointClass offsetForClass put: #ObjClass;		at: pointClass offsetForIVs put: #(#class #x #y #color);		at: pointClass offsetForSuperclass put: #ObjPoint;		at: pointClass offsetForMethodDict put: IdentityDictionary new.	Obj declareClass: coloredPointClass.	(coloredPointClass at: coloredPointClass offsetForMethodDict)		at: #print			put:			([ :arg1 | 			[ :arg2 | 			| tmp2 |			tmp2 := Transcript.			tmp2				show: 'I''am a colored point';				cr ] ] value: pointClass);		at: #foo			put:			([ :arg3 | 			[ :arg4 | 			(arg4 super: #foo withArguments: #() from: arg3)				+ (arg4 super: #foo withArguments: #() from: arg3) ] ]				value: pointClass);		at: #bar			put:			([ :arg5 | 			[ :arg6 | 			(arg6 super: #bar withArguments: #() from: arg5)				+ (arg6 super: #bar withArguments: #() from: arg5) ] ]				value: pointClass)! !!ObjTest methodsFor: 'setup'!assemblePointClass	| tmp1 |	tmp1 := Obj giveClassNamed: #ObjClass.	pointClass := Obj new: (tmp1 at: tmp1 offsetForIVs) size.	pointClass		at: pointClass offsetForName put: #ObjPoint;		at: pointClass offsetForClass put: #ObjClass;		at: pointClass offsetForIVs put: #(#class #x #y);		at: pointClass offsetForKeywords put: #(#x: #y:);		at: pointClass offsetForSuperclass put: #ObjObject;		at: pointClass offsetForMethodDict put: IdentityDictionary new.	Obj declareClass: pointClass.	(pointClass at: pointClass offsetForMethodDict)		at: #x			put:			([ :arg1 | [ :arg2 | arg2 valueOfInstanceVariable: #x ] ]				value: objectClass);		at: #print			put:			([ :arg3 | 			[ :arg4 | 			| tmp3 |			tmp3 := Transcript.			tmp3				show: 'I''am a Point';				cr ] ] value: objectClass);		at: #foo			put:			([ :arg5 | 			[ :arg6 | 			| tmp5 |			tmp5 := Transcript.			tmp5				show: 'ObjPoint>>foo';				cr.			5 ] ] value: objectClass)! !!ObjTest methodsFor: 'setup'!assembleObjectClass	objectClass := Obj new: 6.	objectClass		at: objectClass offsetForName put: #ObjObject;		at: objectClass offsetForClass put: #ObjClass;		at: objectClass offsetForIVs put: #(#class);		at: objectClass offsetForKeywords put: #();		at: objectClass offsetForSuperclass put: nil;		at: objectClass offsetForMethodDict put: IdentityDictionary new.	Obj declareClass: objectClass.	(objectClass at: objectClass offsetForMethodDict)		at: #print			put:			([ :arg1 | 			[ :arg2 | 			| tmp2 |			tmp2 := Transcript.			tmp2				show: 'I''am an Object';				cr ] ] value: nil);		at: #error			put:			([ :arg3 | 			[ :arg4 :arg5 | 			| tmp4 |			tmp4 := Transcript.			tmp4				show: 'Error: selector ' , arg5 first printString , ' not understood';				cr.			Error signal ] ] value: nil);		at: #getIV			put:			([ :arg6 | [ :arg7 :arg8 | arg7 valueOfInstanceVariable: arg8 ] ]				value: nil);		at: #setIV			put:			([ :arg9 | [ :arg10 :arg11 :arg12 | arg10 at: (arg10 offsetFromObjectOfInstanceVariable: arg11) put: arg12 ] ]				value: nil);		at: #bar put: ([ :arg13 | [ :arg14 | 5 ] ] value: nil)! !!ObjTest methodsFor: 'setup'!assemblePointInstance	aPoint := Obj new: 3.	aPoint		at: 1 put: #ObjPoint;		at: 2 put: 10;		at: 3 put: 15! !!ObjTest methodsFor: 'setup'!setUp	Obj initialize.	self		assembleClassClass;		assemblePointClass;		assembleObjectClass;		assembleColoredPointClass;		assemblePointInstance;		assembleColoredInstance;		assembleIncrementalColoredInstance;		assembleIncrementalColoredPointClass! !!ObjTest methodsFor: 'setup'!assembleIncrementalColoredInstance	aIncrementalColoredPoint := Obj new: 4.	aIncrementalColoredPoint		at: 1 put: #ObjIncrementalColoredPoint;		at: 2 put: 10;		at: 3 put: 15;		at: 4 put: #blue! !!ObjTest methodsFor: 'step3-tests-class access'!testClassAccess	self assert: aPoint objClass = pointClass! !!ObjTest methodsFor: 'step4-tests-iv management'!testIVOffset	self		assert: (pointClass offsetFromClassOfInstanceVariable: #x) = 2;		assert: (pointClass offsetFromClassOfInstanceVariable: #lulu) = 0! !!ObjTest methodsFor: 'step4-tests-iv management'!testIVOffsetAndValue	self		assert: (aPoint offsetFromObjectOfInstanceVariable: #x) = 2;		assert: (aPoint valueOfInstanceVariable: #x) = 10! !!ObjTest methodsFor: 'step8-tests-instance variable inheritance'!testInstanceVariableInheritance	self		assert:			(Obj new				computeNewIVFrom: #(#a #b #c #d) asOrderedCollection				with: #(#a #z #b #t) asOrderedCollection)				= #(#a #b #c #d #z #t) asOrderedCollection;		assert:			(Obj new				computeNewIVFrom: #() asOrderedCollection				with: #(#a #z #b #t) asOrderedCollection)				= #(#a #z #b #t) asOrderedCollection! !!ObjTest methodsFor: 'tests-MethodsManagement'!testMethodManagmentNotUnderstandBadMethod	self assert: (pointClass doesUnderstand: #xx) not! !!ObjTest methodsFor: 'tests-MethodsManagement'!testMethodManagmentUnderstandGoodMethod	self assert: (pointClass doesUnderstand: #x)! !!ObjTest methodsFor: 'tests-MethodsManagement'!testMethodManagmentAddRemoveMethods	pointClass		addMethod: #xx		args: ''		withBody: 'objself valueOfInstanceVariable: #x '.	self		assert: ((pointClass bodyOfMethod: #xx) value: aPoint) = 10;		assert: (pointClass doesUnderstand: #xx).	pointClass removeMethod: #xx.	self		assert: (pointClass doesUnderstand: #xx) not;		assert: ((pointClass bodyOfMethod: #x) value: aPoint) = 10! !!ObjTest methodsFor: 'tests-MethodsManagement'!testMethodManagmentBodyOfMethod	self assert: ((pointClass bodyOfMethod: #x) value: aPoint) = 10! !!ObjTest methodsFor: 'step7-tests-initialize'!testInitialize	| tmp1 |	tmp1 := pointClass allocateAnInstance.	tmp1 initializeUsing: #(#y: 2 #z: 3 #t: 55 #x: 1).	self		assert: (tmp1 at: 1) equals: #ObjPoint;		assert: (tmp1 at: 2) equals: 1;		assert: (tmp1 at: 3) equals: 2! !!ObjTest methodsFor: 'tests-StaticInheritanceOfInstanceVariables'!testInstanceVariableInheritanceFromAObject	aIncrementalColoredPoint objClass		objIVs:			(aIncrementalColoredPoint				computeNewIVFrom: aPoint objClass objIVs				with: aIncrementalColoredPoint objClass objIVs).	self		assert: (aPoint offsetFromObjectOfInstanceVariable: #x) = 2;		assert: (aIncrementalColoredPoint offsetFromObjectOfInstanceVariable: #x) = 2! !!ObjTest methodsFor: 'tests-StaticInheritanceOfInstanceVariables'!testInstanceVariableInheritanceFromAClass	aIncrementalColoredPoint objClass		objIVs:			(aIncrementalColoredPoint				computeNewIVFrom: aPoint objClass objIVs				with: aIncrementalColoredPoint objClass objIVs).	self		assert: (pointClass offsetFromClassOfInstanceVariable: #x) = 2;		assert:			(incrementalColoredPointClass offsetFromClassOfInstanceVariable: #x)				= 2! !!ObjTest methodsFor: 'tests-StaticInheritanceOfInstanceVariables'!testInstanceVariableInheritanceNotFind	self		should: [ aPoint offsetFromObjectOfInstanceVariable: #zork ]		raise: Error! !!ObjTest methodsFor: 'tests-StaticInheritanceOfInstanceVariables'!testInstanceVariableInheritanceNumberOfInstanceVar	self		assert: pointClass numberOfIVs = 3;		assert: coloredPointClass numberOfIVs = 4! !!ObjTest methodsFor: 'step5-tests-allocate'!testAllocate	| tmp1 |	tmp1 := pointClass allocateAnInstance.	self		assert: (tmp1 at: 1) = #ObjPoint;		assert: tmp1 size = 3;		assert: (tmp1 at: 2) isNil;		assert: (tmp1 at: 3) isNil;		assert: tmp1 objClass = pointClass! !!ObjTest methodsFor: 'tests'!testMethodDefinition	self		assert: (pointClass doesUnderstand: #x);		assert: (pointClass doesUnderstand: #xx) not.	pointClass addMethod: #xx args: '' withBody: 'objself'.	self		assert: (pointClass doesUnderstand: #xx);		assert: ((pointClass bodyOfMethod: #xx) value: 22) = 22.	pointClass		addMethod: #getgetx		args: ''		withBody: 'objself valueOfInstanceVariable: #x'.	self		assert: (pointClass doesUnderstand: #getgetx);		assert: ((pointClass bodyOfMethod: #getgetx) value: aPoint) = 10! !!ObjTest methodsFor: 'tests'!testMethodSelfSend	self		assert: (aPoint send: #x withArguments: #()) = 10;		assert: (aPoint send: #getIV withArguments: #(#x)) = 10.	aPoint send: #setIV withArguments: #(#y 22).	self assert: (aPoint send: #getIV withArguments: #(#y)) = 22! !!ObjTest methodsFor: 'tests'!testMethodSuperCall	self		assert: (aPoint send: #foo withArguments: #()) = 5;		assert: (aColoredPoint send: #foo withArguments: #()) = 10! !!ObjTest methodsFor: 'tests'!testMethodSuperCallOverBigHierarchy	self		assert: (aPoint send: #bar withArguments: #()) = 5;		assert: (aColoredPoint send: #bar withArguments: #()) = 10! !!ObjTest methodsFor: 'tests'!testErrorRedefinition	self should: [ aPoint send: #zork withArguments: #() ] raise: Error.	(pointClass at: pointClass offsetForMethodDict)		at: #error		put: ([ :arg1 | [ :arg2 :arg3 | 33 ] ] value: objectClass).	self assert: (aPoint send: #zork withArguments: #()) = 33.	(pointClass at: pointClass offsetForMethodDict)		at: #error		put: ([ :arg4 | [ :arg5 :arg6 | 33 ] ] value: objectClass).	self assert: (aPoint send: #zork withArguments: #(44)) = 33! !!ObjTest methodsFor: 'tests'!testMethodNotFoundRaiseError	self should: [ aPoint send: #zork withArguments: #() ] raise: Error! !!ObjTest methodsFor: 'tests'!testPrimitiveStructure	self		assert: pointClass objClassId = #ObjClass;		assert: pointClass objName = #ObjPoint;		assert: pointClass objSuperclassId = #ObjObject;		assert: pointClass objIVs = #(#class #x #y);		assert: pointClass objKeywords = #(#x: #y:);		assert: (pointClass objMethodDict = nil) not! !!ObjTest methodsFor: 'tests' stamp: 'pm 11/3/2018 20:31'!testMethodLookup	self assert: ((pointClass lookup: #x) isKindOf: BlockClosure)! !!ObjTest methodsFor: 'tests'!testMethodManagement	self		assert: (pointClass doesUnderstand: #x);		assert: (pointClass doesUnderstand: #xx) not.	pointClass		addMethod: #xx		args: ''		withBody: 'objself valueOfInstanceVariable: #x '.	self		assert: ((pointClass bodyOfMethod: #xx) value: aPoint) = 10;		assert: (pointClass doesUnderstand: #xx).	pointClass removeMethod: #xx.	self		assert: (pointClass doesUnderstand: #xx) not;		assert: ((pointClass bodyOfMethod: #x) value: aPoint) = 10! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup'!testRaisesErrorSendWhenErrorInLookup	self		should: [ pointClass send: #zork withArguments: {aPoint} ]		raise: Error! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup'!testErrorRaisedSendWhenErrorInLookup	self		should: [ pointClass sendError: #zork withArgs: {aPoint} ]		raise: Error! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup'!testSendErrorRaisesErrorSendWhenErrorInLookup	self		should: [ pointClass sendError: #zork withArgs: {aPoint} ]		raise: Error! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup'!testMethodSelfSendUnarySend	self		assert: (aPoint send: #x withArguments: #()) = 10;		assert: (aColoredPoint send: #x withArguments: #()) = 10! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup'!testNilWhenErrorInLookup	self assert: (pointClass lookup: #zork) isNil! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup'!testMethodLookupFindSuperMethod	self assert: ((coloredPointClass lookup: #x) isKindOf: BlockClosure)! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup'!testMethodLookupStop	| tmp1 |	tmp1 := pointClass lookup: #zork.	self		assert: tmp1 isNil;		should: [ pointClass sendError: #error withArgs: {aPoint} ]			raise: Error.	tmp1 := pointClass lookup: #error.	self		assert: (tmp1 isKindOf: BlockClosure);		assert: ('*Error*' match: tmp1 printString);		should: [ (pointClass lookup: #zork) value: 'r' value: #e ]			raise: Error! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup'!testMethodLookupFindSimpleMethod	self assert: ((pointClass lookup: #x) isKindOf: BlockClosure)! !!ObjTest methodsFor: 'step6-tests-keywords'!testKeywords	| tmp1 |	tmp1 := Obj new.	self		assert:			(tmp1 generateKeywords: #(#titi #toto #lulu))				= #(#titi: #toto: #lulu:);		assert: (tmp1 keywordValue: #x getFrom: #(#toto 33 #x 23) ifAbsent: 2) = 23;		assert: (tmp1 keywordValue: #x getFrom: #(#toto 23) ifAbsent: 2) = 2;		assert:			(tmp1				returnValuesFrom: #(#x 22 #y 35)				followingSchema: #(#y #yy #x #y)) = #(35 nil 22 35)! !!ObjTest methodsFor: 'step1-tests-structure of objects'!testPrimitiveStructureObjClassIdForSimpleObject	self assert: aPoint objClassId = #ObjPoint! !!ObjTest methodsFor: 'step1-tests-structure of objects'!testPrimitiveStructureObjClassId	self assert: pointClass objClassId = #ObjClass! !TestCase subclass: #RawObjTest	instanceVariableNames: 'objectClass aPoint coloredPointClass pointClass classClass aColoredPoint aIncrementalColoredPoint incrementalColoredPointClass'	classVariableNames: ''	poolDictionaries: ''	category: 'ObjVSkeleton'!!RawObjTest methodsFor: 'step1-tests-structure of objects'!testPrimitiveStructureObjClassIdForSimpleObject	self assert: aPoint objClassId = #ObjPoint! !!RawObjTest methodsFor: 'step1-tests-structure of objects'!testPrimitiveStructureObjClassId	self assert: pointClass objClassId = #ObjClass! !!RawObjTest methodsFor: 'step3-tests-class access'!testClassAccess	self assert: aPoint objClass = pointClass! !!RawObjTest methodsFor: 'step2-tests-structure of classes'!testPrimitiveStructureObjKeywords	self assert: pointClass objKeywords = #(#x: #y:)! !!RawObjTest methodsFor: 'step2-tests-structure of classes'!testPrimitiveStructureObjMethodDict	self assert: (pointClass objMethodDict = nil) not! !!RawObjTest methodsFor: 'step2-tests-structure of classes'!testPrimitiveStructureObjName	self assert: pointClass objName = #ObjPoint! !!RawObjTest methodsFor: 'step2-tests-structure of classes'!testPrimitiveStructureObjIVs	self assert: pointClass objIVs = #(#class #x #y)! !!RawObjTest methodsFor: 'step2-tests-structure of classes'!testPrimitiveStructureObjSuperclassId	self assert: pointClass objSuperclassId = #ObjObject! !!RawObjTest methodsFor: 'setup'!assembleClassClass	classClass := Obj new: 6.	classClass		at: 2 put: #ObjClass;		at: 1 put: #ObjClass;		at: 4 put: #(#class #name #superclass #iv #keywords #methodDict);		at: 5 put: #(#name: #superclass: #iv: #keywords: #methodDict:);		at: 3 put: #ObjObject;		at: 6 put: IdentityDictionary new.	Obj declareClass: classClass! !!RawObjTest methodsFor: 'setup'!assembleColoredInstance	aColoredPoint := Obj new: 4.	aColoredPoint		at: 1 put: #ObjColoredPoint;		at: 2 put: 10;		at: 3 put: 15;		at: 4 put: #blue! !!RawObjTest methodsFor: 'setup'!assembleIncrementalColoredPointClass	incrementalColoredPointClass := Obj new: 6.	incrementalColoredPointClass		at: 2 put: #ObjIncrementalColoredPoint;		at: 1 put: #ObjClass;		at: 4 put: #(#color);		at: 3 put: #ObjPoint;		at: 6 put: IdentityDictionary new.	Obj declareClass: incrementalColoredPointClass.	(incrementalColoredPointClass		at: incrementalColoredPointClass offsetForMethodDict)		at: #print			put:			([ :arg1 | 			[ :arg2 | 			| tmp2 |			tmp2 := Transcript.			tmp2				show: 'I''am a colored point';				cr ] ] value: pointClass);		at: #foo			put:			([ :arg3 | 			[ :arg4 | 			(arg4 super: #foo withArguments: #() from: arg3)				+ (arg4 super: #foo withArguments: #() from: arg3) ] ]				value: pointClass);		at: #bar			put:			([ :arg5 | 			[ :arg6 | 			(arg6 super: #bar withArguments: #() from: arg5)				+ (arg6 super: #bar withArguments: #() from: arg5) ] ]				value: pointClass)! !!RawObjTest methodsFor: 'setup'!assembleColoredPointClass	coloredPointClass := Obj new: 6.	coloredPointClass		at: 2 put: #ObjColoredPoint;		at: 1 put: #ObjClass;		at: 4 put: #(#class #x #y #color);		at: 3 put: #ObjPoint;		at: 6 put: IdentityDictionary new.	Obj declareClass: coloredPointClass.	(coloredPointClass at: coloredPointClass offsetForMethodDict)		at: #print			put:			([ :arg1 | 			[ :arg2 | 			| tmp2 |			tmp2 := Transcript.			tmp2				show: 'I''am a colored point';				cr ] ] value: pointClass);		at: #foo			put:			([ :arg3 | 			[ :arg4 | 			(arg4 super: #foo withArguments: #() from: arg3)				+ (arg4 super: #foo withArguments: #() from: arg3) ] ]				value: pointClass);		at: #bar			put:			([ :arg5 | 			[ :arg6 | 			(arg6 super: #bar withArguments: #() from: arg5)				+ (arg6 super: #bar withArguments: #() from: arg5) ] ]				value: pointClass)! !!RawObjTest methodsFor: 'setup'!assemblePointClass	| tmp1 |	tmp1 := Obj giveClassNamed: #ObjClass.	pointClass := Obj new: (tmp1 at: tmp1 offsetForIVs) size.	pointClass		at: 2 put: #ObjPoint;		at: 1 put: #ObjClass;		at: 4 put: #(#class #x #y);		at: 5 put: #(#x: #y:);		at: 3 put: #ObjObject;		at: 6 put: IdentityDictionary new.	Obj declareClass: pointClass.	(pointClass at: pointClass offsetForMethodDict)		at: #x			put:			([ :arg1 | [ :arg2 | arg2 valueOfInstanceVariable: #x ] ]				value: objectClass);		at: #print			put:			([ :arg3 | 			[ :arg4 | 			| tmp3 |			tmp3 := Transcript.			tmp3				show: 'I''am a Point';				cr ] ] value: objectClass);		at: #foo			put:			([ :arg5 | 			[ :arg6 | 			| tmp5 |			tmp5 := Transcript.			tmp5				show: 'ObjPoint>>foo';				cr.			5 ] ] value: objectClass)! !!RawObjTest methodsFor: 'setup'!assembleObjectClass	objectClass := Obj new: 6.	objectClass		at: 2 put: #ObjObject;		at: 1 put: #ObjClass;		at: objectClass offsetForIVs put: #(#class);		at: objectClass offsetForKeywords put: #();		at: objectClass offsetForSuperclass put: nil;		at: objectClass offsetForMethodDict put: IdentityDictionary new.	Obj declareClass: objectClass.	(objectClass at: objectClass offsetForMethodDict)		at: #print			put:			([ :arg1 | 			[ :arg2 | 			| tmp2 |			tmp2 := Transcript.			tmp2				show: 'I''am an Object';				cr ] ] value: nil);		at: #error			put:			([ :arg3 | 			[ :arg4 :arg5 | 			| tmp4 |			tmp4 := Transcript.			tmp4				show: 'Error: selector ' , arg5 printString , ' not understood';				cr.			Error signal ] ] value: nil);		at: #getIV			put:			([ :arg6 | [ :arg7 :arg8 | arg7 valueOfInstanceVariable: arg8 ] ]				value: nil);		at: #setIV			put:			([ :arg9 | [ :arg10 :arg11 :arg12 | arg10 at: (arg10 offsetFromObjectOfInstanceVariable: arg11) put: arg12 ] ]				value: nil);		at: #bar put: ([ :arg13 | [ :arg14 | 5 ] ] value: nil)! !!RawObjTest methodsFor: 'setup'!assemblePointInstance	aPoint := Obj new: 3.	aPoint		at: 1 put: #ObjPoint;		at: 2 put: 10;		at: 3 put: 15! !!RawObjTest methodsFor: 'setup'!setUp	Obj initialize.	self		assembleClassClass;		assemblePointClass;		assembleObjectClass;		assembleColoredPointClass;		assemblePointInstance;		assembleColoredInstance;		assembleIncrementalColoredInstance;		assembleIncrementalColoredPointClass! !!RawObjTest methodsFor: 'setup'!assembleIncrementalColoredInstance	aIncrementalColoredPoint := Obj new: 4.	aIncrementalColoredPoint		at: 1 put: #ObjIncrementalColoredPoint;		at: 2 put: 10;		at: 3 put: 15;		at: 4 put: #blue! !Obj initialize!